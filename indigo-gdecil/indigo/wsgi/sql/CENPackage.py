-- Generated by Ora2Pg, the Oracle database Schema converter, version 13.0
-- Copyright 2000-2014 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=gippo-PC;sid=XE

SET client_encoding TO 'UTF8';

\set ON_ERROR_STOP ON

-- Oracle package 'JSON_AC' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS json_ac CASCADE;
CREATE SCHEMA json_ac;


CREATE OR REPLACE FUNCTION json_ac.object_remove (p_self in out nocopy json, pair_name text)  RETURNS nocopy AS $body$
BEGIN p_self.remove(pair_name); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_put (p_self in out nocopy json, pair_name text, pair_value json_value, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.put(pair_name, pair_value, position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_put (p_self in out nocopy json, pair_name text, pair_value text, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.put(pair_name, pair_value, position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_put (p_self in out nocopy json, pair_name text, pair_value bigint, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.put(pair_name, pair_value, position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_put (p_self in out nocopy json, pair_name text, pair_value boolean, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.put(pair_name, pair_value, position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_check_duplicate (p_self in out nocopy json, v_set boolean)  RETURNS nocopy AS $body$
BEGIN p_self.check_duplicate(v_set); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_remove_duplicates (p_self in out nocopy json)  RETURNS nocopy AS $body$
BEGIN p_self.remove_duplicates; end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_put (p_self in out nocopy json, pair_name text, pair_value json, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.put(pair_name, pair_value, position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_put (p_self in out nocopy json, pair_name text, pair_value json_list, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.put(pair_name, pair_value, position); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_count (p_self in json)  RETURNS bigint AS $body$
BEGIN return p_self.count; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_get (p_self in json, pair_name text)  RETURNS json_value AS $body$
BEGIN return p_self.get(pair_name); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_get (p_self in json, position pls_integer)  RETURNS json_value AS $body$
BEGIN return p_self.get(position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_index_of (p_self in json, pair_name text)  RETURNS bigint AS $body$
BEGIN return p_self.index_of(pair_name); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_exist (p_self in json, pair_name text)  RETURNS boolean AS $body$
BEGIN return p_self.exist(pair_name); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_to_char (p_self in json, spaces boolean default true, chars_per_line bigint default 0)  RETURNS varchar AS $body$
BEGIN return p_self.to_char(spaces, chars_per_line); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_to_clob (p_self in json, buf in out nocopy text, spaces boolean default false, chars_per_line bigint default 0, erase_clob boolean default true)  RETURNS nocopy AS $body$
BEGIN p_self.to_clob(buf, spaces, chars_per_line, erase_clob); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_print (p_self in json, spaces boolean default true, chars_per_line bigint default 8192, jsonp text default null)  RETURNS VOID AS $body$
BEGIN p_self.print(spaces, chars_per_line, jsonp); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_htp (p_self in json, spaces boolean default false, chars_per_line bigint default 0, jsonp text default null)  RETURNS VOID AS $body$
BEGIN p_self.htp(spaces, chars_per_line, jsonp); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_to_json_value (p_self in json)  RETURNS json_value AS $body$
BEGIN return p_self.to_json_value; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_path (p_self in json, json_path text, base bigint default 1)  RETURNS json_value AS $body$
BEGIN return p_self.path(json_path, base); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_path_put (p_self in out nocopy json, json_path text, elem json_value, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_path_put (p_self in out nocopy json, json_path text, elem text  , base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_path_put (p_self in out nocopy json, json_path text, elem bigint    , base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_path_put (p_self in out nocopy json, json_path text, elem boolean   , base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_path_put (p_self in out nocopy json, json_path text, elem json_list , base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_path_put (p_self in out nocopy json, json_path text, elem json      , base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_path_remove (p_self in out nocopy json, json_path text, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_remove(json_path, base); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_get_values (p_self in json)  RETURNS json_list AS $body$
BEGIN return p_self.get_values; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.object_get_keys (p_self in json)  RETURNS json_list AS $body$
BEGIN return p_self.get_keys; end;

  --json_list type

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_append (p_self in out nocopy json_list, elem json_value, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.append(elem, position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_append (p_self in out nocopy json_list, elem text, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.append(elem, position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_append (p_self in out nocopy json_list, elem bigint, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.append(elem, position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_append (p_self in out nocopy json_list, elem boolean, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.append(elem, position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_append (p_self in out nocopy json_list, elem json_list, position pls_integer default null)  RETURNS nocopy AS $body$
BEGIN p_self.append(elem, position); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_replace (p_self in out nocopy json_list, position pls_integer, elem json_value)  RETURNS nocopy AS $body$
BEGIN p_self.replace(position, elem); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_replace (p_self in out nocopy json_list, position pls_integer, elem text)  RETURNS nocopy AS $body$
BEGIN p_self.replace(position, elem); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_replace (p_self in out nocopy json_list, position pls_integer, elem bigint)  RETURNS nocopy AS $body$
BEGIN p_self.replace(position, elem); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_replace (p_self in out nocopy json_list, position pls_integer, elem boolean)  RETURNS nocopy AS $body$
BEGIN p_self.replace(position, elem); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_replace (p_self in out nocopy json_list, position pls_integer, elem json_list)  RETURNS nocopy AS $body$
BEGIN p_self.replace(position, elem); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_count (p_self in json_list)  RETURNS bigint AS $body$
BEGIN return p_self.count; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_remove (p_self in out nocopy json_list, position pls_integer)  RETURNS nocopy AS $body$
BEGIN p_self.remove(position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_remove_first (p_self in out nocopy json_list)  RETURNS nocopy AS $body$
BEGIN p_self.remove_first; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_remove_last (p_self in out nocopy json_list)  RETURNS nocopy AS $body$
BEGIN p_self.remove_last; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_get (p_self in json_list, position pls_integer)  RETURNS json_value AS $body$
BEGIN return p_self.get(position); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_head (p_self in json_list)  RETURNS json_value AS $body$
BEGIN return p_self.head; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_last (p_self in json_list)  RETURNS json_value AS $body$
BEGIN return p_self.last; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_tail (p_self in json_list)  RETURNS json_list AS $body$
BEGIN return p_self.tail; end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_to_char (p_self in json_list, spaces boolean default true, chars_per_line bigint default 0)  RETURNS varchar AS $body$
BEGIN return p_self.to_char(spaces, chars_per_line); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_to_clob (p_self in json_list, buf in out nocopy text, spaces boolean default false, chars_per_line bigint default 0, erase_clob boolean default true)  RETURNS nocopy AS $body$
BEGIN p_self.to_clob(buf, spaces, chars_per_line, erase_clob); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_print (p_self in json_list, spaces boolean default true, chars_per_line bigint default 8192, jsonp text default null)  RETURNS VOID AS $body$
BEGIN p_self.print(spaces, chars_per_line, jsonp); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_htp (p_self in json_list, spaces boolean default false, chars_per_line bigint default 0, jsonp text default null)  RETURNS VOID AS $body$
BEGIN p_self.htp(spaces, chars_per_line, jsonp); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_path (p_self in json_list, json_path text, base bigint default 1)  RETURNS json_value AS $body$
BEGIN return p_self.path(json_path, base); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_path_put (p_self in out nocopy json_list, json_path text, elem json_value, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_path_put (p_self in out nocopy json_list, json_path text, elem text  , base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_path_put (p_self in out nocopy json_list, json_path text, elem bigint    , base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_path_put (p_self in out nocopy json_list, json_path text, elem boolean   , base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_path_put (p_self in out nocopy json_list, json_path text, elem json_list , base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_put(json_path, elem, base); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_path_remove (p_self in out nocopy json_list, json_path text, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN p_self.path_remove(json_path, base); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.array_to_json_value (p_self in json_list)  RETURNS json_value AS $body$
BEGIN return p_self.to_json_value; end;

  --json_value



$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_get_type (p_self in json_value)  RETURNS varchar AS $body$
BEGIN return p_self.get_type; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_get_string (p_self in json_value, max_byte_size bigint default null, max_char_size bigint default null)  RETURNS varchar AS $body$
BEGIN return p_self.get_string(max_byte_size, max_char_size); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_get_string (p_self in json_value, buf in out nocopy text)  RETURNS nocopy AS $body$
BEGIN p_self.get_string(buf); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_get_number (p_self in json_value)  RETURNS bigint AS $body$
BEGIN return p_self.get_number; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_get_bool (p_self in json_value)  RETURNS boolean AS $body$
BEGIN return p_self.get_bool; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_get_null (p_self in json_value)  RETURNS varchar AS $body$
BEGIN return p_self.get_null; end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_is_object (p_self in json_value)  RETURNS boolean AS $body$
BEGIN return p_self.is_object; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_is_array (p_self in json_value)  RETURNS boolean AS $body$
BEGIN return p_self.is_array; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_is_string (p_self in json_value)  RETURNS boolean AS $body$
BEGIN return p_self.is_string; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_is_number (p_self in json_value)  RETURNS boolean AS $body$
BEGIN return p_self.is_number; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_is_bool (p_self in json_value)  RETURNS boolean AS $body$
BEGIN return p_self.is_bool; end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_is_null (p_self in json_value)  RETURNS boolean AS $body$
BEGIN return p_self.is_null; end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_to_char (p_self in json_value, spaces boolean default true, chars_per_line bigint default 0)  RETURNS varchar AS $body$
BEGIN return p_self.to_char(spaces, chars_per_line); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_to_clob (p_self in json_value, buf in out nocopy text, spaces boolean default false, chars_per_line bigint default 0, erase_clob boolean default true)  RETURNS nocopy AS $body$
BEGIN p_self.to_clob(buf, spaces, chars_per_line, erase_clob); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_print (p_self in json_value, spaces boolean default true, chars_per_line bigint default 8192, jsonp text default null)  RETURNS VOID AS $body$
BEGIN p_self.print(spaces, chars_per_line, jsonp); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_htp (p_self in json_value, spaces boolean default false, chars_per_line bigint default 0, jsonp text default null)  RETURNS VOID AS $body$
BEGIN p_self.htp(spaces, chars_per_line, jsonp); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ac.jv_value_of (p_self in json_value, max_byte_size bigint default null, max_char_size bigint default null)  RETURNS varchar AS $body$
BEGIN return p_self.value_of(max_byte_size, max_char_size); end;

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'JSON_AC' declaration

-- Oracle package 'JSON_DYN' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS json_dyn CASCADE;
CREATE SCHEMA json_dyn;

/*
  -- 11gR2
  function executeList(stmt in out sys_refcursor) return json_list as
    l_cur number;
  begin
    l_cur := dbms_sql.to_cursor_number(stmt);
    return json_dyn.executeList(null, null, l_cur);
  end;

  -- 11gR2
  function executeObject(stmt in out sys_refcursor) return json as
    l_cur number;
  begin
    l_cur := dbms_sql.to_cursor_number(stmt);
    return json_dyn.executeObject(null, null, l_cur);
  end;
*/



CREATE OR REPLACE FUNCTION json_dyn.bind_json (l_cur bigint, bindvar json)  RETURNS VOID AS $body$
DECLARE

    keylist json_list := bindvar.get_keys();
  
BEGIN
    for i in 1 .. keylist.count loop
      if(bindvar.get(i).get_type = 'numeric') then
        dbms_sql.bind_variable(l_cur, ':'||keylist.get(i).get_string, bindvar.get(i).get_number);
      elsif(bindvar.get(i).get_type = 'array') then
        declare
          v_bind dbms_sql.varchar2_table;
          v_arr  json_list := json_list(bindvar.get(i));
        begin
          for j in 1 .. v_arr.count loop
            v_bind(j) := v_arr.get(j).value_of;
          end loop;
          dbms_sql.bind_array(l_cur, ':'||keylist.get(i).get_string, v_bind);
        end;
      else
        dbms_sql.bind_variable(l_cur, ':'||keylist.get(i).get_string, bindvar.get(i).value_of());
      end if;
    end loop;
  END;

$body$
LANGUAGE PLPGSQL;


  /* list with objects */


CREATE OR REPLACE FUNCTION json_dyn.executelist (stmt text, bindvar json, cur_num bigint)  RETURNS json_list AS $body$
DECLARE

    l_cur bigint;
    l_dtbl dbms_sql.desc_tab;
    l_cnt bigint;
    l_status bigint;
    l_val varchar(4000);
    outer_list json_list := json_list();
    inner_obj json;
    conv bigint;
    read_date timestamp;
    read_clob text;
    read_blob bytea;
    col_type bigint;
  
BEGIN
    if((cur_num IS NOT NULL AND cur_num::text <> '')) then
      l_cur := cur_num;
    else
      l_cur := dbms_sql.open_cursor;
      dbms_sql.parse(l_cur, stmt, dbms_sql.native);
      if((bindvar IS NOT NULL AND bindvar::text <> '')) then bind_json(l_cur, bindvar); end if;
    end if;
    dbms_sql.describe_columns(l_cur, l_cnt, l_dtbl);
    for i in 1..l_cnt loop
      col_type := l_dtbl(i).col_type;
      --dbms_output.put_line(col_type);
      if(col_type = 12) then
        dbms_sql.define_column(l_cur,i,read_date);
      elsif(col_type = 112) then
        dbms_sql.define_column(l_cur,i,read_clob);
      elsif(col_type = 113) then
        dbms_sql.define_column(l_cur,i,read_blob);
      elsif(col_type in (1,2,96)) then
        dbms_sql.define_column(l_cur,i,l_val,4000);
      end if;
    end loop;

    if(coalesce(cur_num::text, '') = '') then l_status := dbms_sql.execute(l_cur); end if;

    --loop through rows
    while ( dbms_sql.fetch_rows(l_cur) > 0 ) loop
      inner_obj := json(); --init for each row
      --loop through columns
      for i in 1..l_cnt loop
        case true
        --handling string types
        when l_dtbl(i).col_type in (1,96) then -- varchar2
          dbms_sql.column_value(l_cur,i,l_val);
          if(coalesce(l_val::text, '') = '') then
            if(null_as_empty_string) then
              inner_obj.put(l_dtbl(i).col_name, ''); --treatet as emptystring?
            else
              inner_obj.put(l_dtbl(i).col_name, json_value.makenull); --null
            end if;
          else
            inner_obj.put(l_dtbl(i).col_name, json_value(l_val)); --null
          end if;
          --dbms_output.put_line(l_dtbl(i).col_name||' --> '||l_val||'varchar2' ||l_dtbl(i).col_type);
        --handling number types
        when l_dtbl(i).col_type = 2 then -- number
          dbms_sql.column_value(l_cur,i,l_val);
          conv := l_val;
          inner_obj.put(l_dtbl(i).col_name, conv);
          -- dbms_output.put_line(l_dtbl(i).col_name||' --> '||l_val||'number ' ||l_dtbl(i).col_type);
        when l_dtbl(i).col_type = 12 then -- date
          if(include_dates) then
            dbms_sql.column_value(l_cur,i,read_date);
            inner_obj.put(l_dtbl(i).col_name, json_ext.to_json_value(read_date));
          end if;
          --dbms_output.put_line(l_dtbl(i).col_name||' --> '||l_val||'date ' ||l_dtbl(i).col_type);
        when l_dtbl(i).col_type = 112 then --clob
          if(include_clobs) then
            dbms_sql.column_value(l_cur,i,read_clob);
            inner_obj.put(l_dtbl(i).col_name, json_value(read_clob));
          end if;
        when l_dtbl(i).col_type = 113 then --blob
          if(include_blobs) then
            dbms_sql.column_value(l_cur,i,read_blob);
            if(dbms_lob.getlength(read_blob) > 0) then
              inner_obj.put(l_dtbl(i).col_name, json_ext.encode(read_blob));
            else
              inner_obj.put(l_dtbl(i).col_name, json_value.makenull);
            end if;
          end if;

        else null; --discard other types
        end case;
      end loop;
      outer_list.append(inner_obj.to_json_value);
    end loop;
    dbms_sql.close_cursor(l_cur);
    return outer_list;
  END;

$body$
LANGUAGE PLPGSQL;


  /* object with lists */


CREATE OR REPLACE FUNCTION json_dyn.executeobject (stmt text, bindvar json, cur_num bigint)  RETURNS json AS $body$
DECLARE

    l_cur bigint;
    l_dtbl dbms_sql.desc_tab;
    l_cnt bigint;
    l_status bigint;
    l_val varchar(4000);
    inner_list_names json_list := json_list();
    inner_list_data json_list := json_list();
    data_list json_list;
    outer_obj json := json();
    conv bigint;
    read_date timestamp;
    read_clob text;
    read_blob bytea;
    col_type bigint;
  
BEGIN
    if((cur_num IS NOT NULL AND cur_num::text <> '')) then
      l_cur := cur_num;
    else
      l_cur := dbms_sql.open_cursor;
      dbms_sql.parse(l_cur, stmt, dbms_sql.native);
      if((bindvar IS NOT NULL AND bindvar::text <> '')) then bind_json(l_cur, bindvar); end if;
    end if;
    dbms_sql.describe_columns(l_cur, l_cnt, l_dtbl);
    for i in 1..l_cnt loop
      col_type := l_dtbl(i).col_type;
      if(col_type = 12) then
        dbms_sql.define_column(l_cur,i,read_date);
      elsif(col_type = 112) then
        dbms_sql.define_column(l_cur,i,read_clob);
      elsif(col_type = 113) then
        dbms_sql.define_column(l_cur,i,read_blob);
      elsif(col_type in (1,2,96)) then
        dbms_sql.define_column(l_cur,i,l_val,4000);
      end if;
    end loop;
    if(coalesce(cur_num::text, '') = '') then l_status := dbms_sql.execute(l_cur); end if;

    --build up name_list
    for i in 1..l_cnt loop
      case l_dtbl(i).col_type
        when 1 then inner_list_names.append(l_dtbl(i).col_name);
        when 96 then inner_list_names.append(l_dtbl(i).col_name);
        when 2 then inner_list_names.append(l_dtbl(i).col_name);
        when 12 then if(include_dates) then inner_list_names.append(l_dtbl(i).col_name); end if;
        when 112 then if(include_clobs) then inner_list_names.append(l_dtbl(i).col_name); end if;
        when 113 then if(include_blobs) then inner_list_names.append(l_dtbl(i).col_name); end if;
        else null;
      end case;
    end loop;

    --loop through rows
    while ( dbms_sql.fetch_rows(l_cur) > 0 ) loop
      data_list := json_list();
      --loop through columns
      for i in 1..l_cnt loop
        case true
        --handling string types
        when l_dtbl(i).col_type in (1,96) then -- varchar2
          dbms_sql.column_value(l_cur,i,l_val);
          if(coalesce(l_val::text, '') = '') then
            if(null_as_empty_string) then
              data_list.append(''); --treatet as emptystring?
            else
              data_list.append(json_value.makenull); --null
            end if;
          else
            data_list.append(json_value(l_val)); --null
          end if;
          --dbms_output.put_line(l_dtbl(i).col_name||' --> '||l_val||'varchar2' ||l_dtbl(i).col_type);
        --handling number types
        when l_dtbl(i).col_type = 2 then -- number
          dbms_sql.column_value(l_cur,i,l_val);
          conv := l_val;
          data_list.append(conv);
          -- dbms_output.put_line(l_dtbl(i).col_name||' --> '||l_val||'number ' ||l_dtbl(i).col_type);
        when l_dtbl(i).col_type = 12 then -- date
          if(include_dates) then
            dbms_sql.column_value(l_cur,i,read_date);
            data_list.append(json_ext.to_json_value(read_date));
          end if;
          --dbms_output.put_line(l_dtbl(i).col_name||' --> '||l_val||'date ' ||l_dtbl(i).col_type);
        when l_dtbl(i).col_type = 112 then --clob
          if(include_clobs) then
            dbms_sql.column_value(l_cur,i,read_clob);
            data_list.append(json_value(read_clob));
          end if;
        when l_dtbl(i).col_type = 113 then --blob
          if(include_blobs) then
            dbms_sql.column_value(l_cur,i,read_blob);
            if(dbms_lob.getlength(read_blob) > 0) then
              data_list.append(json_ext.encode(read_blob));
            else
              data_list.append(json_value.makenull);
            end if;
          end if;
        else null; --discard other types
        end case;
      end loop;
      inner_list_data.append(data_list);
    end loop;

    outer_obj.put('names', inner_list_names.to_json_value);
    outer_obj.put('data', inner_list_data.to_json_value);
    dbms_sql.close_cursor(l_cur);
    return outer_obj;
  END;

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'JSON_DYN' declaration

-- Oracle package 'JSON_EXT' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS json_ext CASCADE;
CREATE SCHEMA json_ext;

scanner_exception exception;
  pragma exception_init(scanner_exception, -20100);
  parser_exception exception;
  pragma exception_init(parser_exception, -20101);
  jext_exception exception;
  pragma exception_init(jext_exception, -20110);

  --extra function checks if number has no fraction


CREATE OR REPLACE FUNCTION json_ext.is_integer (v json_value)  RETURNS boolean AS $body$
DECLARE

    myint bigint; --the oracle way to specify an integer
  
BEGIN
    if(v.is_number) then
      myint := v.get_number;
      return (myint = v.get_number); --no rounding errors?
    else
      return false;
    end if;
  end;

  --extension enables json to store dates without comprimising the implementation

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.to_json_value (d timestamp)  RETURNS json_value AS $body$
BEGIN
    return json_value(to_char(d, format_string));
  end;

  --notice that a date type in json is also a varchar2

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.is_date (v json_value)  RETURNS boolean AS $body$
DECLARE

    temp timestamp;
  
BEGIN
    temp := json_ext.to_date2(v);
    return true;
  exception
    when others then
      return false;
  end;

  --convertion is needed to extract dates

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.to_date2 (v json_value)  RETURNS timestamp AS $body$
BEGIN
    if(v.is_string) then
      return to_date(v.get_string, format_string);
    else
      RAISE EXCEPTION 'Anydata did not contain a timestamp-value';
    end if;
  exception
    when others then
      RAISE EXCEPTION 'Anydata did not contain a timestamp on the format: %',format_string;
  end;

  --Json Path parser

$body$
LANGUAGE PLPGSQL;

    build_path varchar(32767) := '[';
    buf varchar(4);
    endstring varchar(1);
    indx bigint := 1;
    ret json_list;



CREATE OR REPLACE FUNCTION json_ext.next_char () RETURNS VOID AS $body$
BEGIN
      if(indx <= length(json_path)) then
        buf := substring(json_path from indx for 1);
        indx := indx + 1;
      else
        buf := null;
      end if;
    end;
    --skip ws

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.skipws () RETURNS VOID AS $body$
BEGIN while(buf in (chr(9),chr(10),chr(13),' ')) loop next_char; end loop; end;

  begin
    next_char();
    while((buf IS NOT NULL AND buf::text <> '')) loop
      if(buf = '.') then
        next_char();
        if(coalesce(buf::text, '') = '') then RAISE EXCEPTION 'JSON Path parse error: . is not a valid json_path end'; end if;
        if(not regexp_like(buf, '^[[alnum:]\_ ]+', 'c') ) then
          RAISE EXCEPTION 'JSON Path parse error: alpha-numeric character or space expected at position %',indx;
        end if;

        if(build_path != '[') then build_path := build_path || ','; end if;
        build_path := build_path || '"';
        while(regexp_like(buf, '^[[alnum:]\_ ]+', 'c') ) loop
          build_path := build_path || buf;
          next_char();
        end loop;
        build_path := build_path || '"';
      elsif(buf = '[') then
        next_char();
        skipws();
        if(coalesce(buf::text, '') = '') then RAISE EXCEPTION 'JSON Path parse error: [ is not a valid json_path end'; end if;
        if(buf in ('1','2','3','4','5','6','7','8','9') or (buf = '0' and base = 0)) then
          if(build_path != '[') then build_path := build_path || ','; end if;
          while(buf in ('0','1','2','3','4','5','6','7','8','9')) loop
            build_path := build_path || buf;
            next_char();
          end loop;
        elsif (regexp_like(buf, '^(\"|\'')', 'c')) then
          endstring := buf;
          if(build_path != '[') then build_path := build_path || ','; end if;
          build_path := build_path || '"';
          next_char();
          if(coalesce(buf::text, '') = '') then RAISE EXCEPTION 'JSON Path parse error: premature json_path end'; end if;
          while(buf != endstring) loop
            build_path := build_path || buf;
            next_char();
            if(coalesce(buf::text, '') = '') then RAISE EXCEPTION 'JSON Path parse error: premature json_path end'; end if;
            if(buf = '\') then
              next_char();
              build_path := build_path || '\' || buf;
              next_char();
            end if;
          end loop;
          build_path := build_path || '"';
          next_char();
        else
          RAISE EXCEPTION 'JSON Path parse error: expected a string or an positive integer at %',indx;
        end if;
        skipws();
        if(coalesce(buf::text, '') = '') then RAISE EXCEPTION 'JSON Path parse error: premature json_path end'; end if;
        if(buf != ']') then RAISE EXCEPTION 'JSON Path parse error: no array ending found. found: %', buf; end if;
        next_char();
        skipws();
      elsif(build_path = '[') then
        if(not regexp_like(buf, '^[[alnum:]\_ ]+', 'c') ) then
          RAISE EXCEPTION 'JSON Path parse error: alpha-numeric character or space expected at position %',indx;
        end if;
        build_path := build_path || '"';
        while(regexp_like(buf, '^[[alnum:]\_ ]+', 'c') ) loop
          build_path := build_path || buf;
          next_char();
        end loop;
        build_path := build_path || '"';
      else
        RAISE EXCEPTION 'JSON Path parse error: expected . or [ found % at position %', buf , indx;
      end if;

    end loop;

    build_path := build_path || ']';
    build_path := replace(replace(replace(replace(replace(build_path, chr(9), '\t'), chr(10), '\n'), chr(13), '\f'), chr(8), '\b'), chr(14), '\r');

    ret := json_list(build_path);
    if(base != 1) then
      --fix base 0 to base 1
      declare
        elem json_value;
      begin
        for i in 1 .. ret.count loop
          elem := ret.get(i);
          if(elem.is_number) then
            ret.replace(i,elem.get_number()+1);
          end if;
        end loop;
      end;
    end if;

    return ret;
  END;

  --JSON Path getters

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.get_json_value (obj json, v_path text, base bigint default 1)  RETURNS json_value AS $body$
DECLARE

    path json_list;
    ret json_value;
    o json; l json_list;
  
BEGIN
    path := parsePath(v_path, base);
    ret := obj.to_json_value;
    if(path.count = 0) then return ret; end if;

    for i in 1 .. path.count loop
      if(path.get(i).is_string()) then
        --string fetch only on json
        o := json(ret);
        ret := o.get(path.get(i).get_string());
      else
        --number fetch on json and json_list
        if(ret.is_array()) then
          l := json_list(ret);
          ret := l.get(path.get(i).get_number());
        else
          o := json(ret);
          l := o.get_values();
          ret := l.get(path.get(i).get_number());
        end if;
      end if;
    end loop;

    return ret;
  exception
    when scanner_exception then raise;
    when parser_exception then raise;
    when jext_exception then raise;
    when others then return null;
  END;

$body$
LANGUAGE PLPGSQL;


  --JSON Path getters


CREATE OR REPLACE FUNCTION json_ext.get_string (obj json, path text, base bigint default 1)  RETURNS varchar AS $body$
DECLARE

    temp json_value;
  
BEGIN
    temp := get_json_value(obj, path, base);
    if(coalesce(temp::text, '') = '' or not temp.is_string) then
      return null;
    else
      return temp.get_string;
    end if;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.get_number (obj json, path text, base bigint default 1)  RETURNS bigint AS $body$
DECLARE

    temp json_value;
  
BEGIN
    temp := get_json_value(obj, path, base);
    if(coalesce(temp::text, '') = '' or not temp.is_number) then
      return null;
    else
      return temp.get_number;
    end if;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.get_json (obj json, path text, base bigint default 1)  RETURNS json AS $body$
DECLARE

    temp json_value;
  
BEGIN
    temp := get_json_value(obj, path, base);
    if(coalesce(temp::text, '') = '' or not temp.is_object) then
      return null;
    else
      return json(temp);
    end if;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.get_json_list (obj json, path text, base bigint default 1)  RETURNS json_list AS $body$
DECLARE

    temp json_value;
  
BEGIN
    temp := get_json_value(obj, path, base);
    if(coalesce(temp::text, '') = '' or not temp.is_array) then
      return null;
    else
      return json_list(temp);
    end if;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.get_bool (obj json, path text, base bigint default 1)  RETURNS boolean AS $body$
DECLARE

    temp json_value;
  
BEGIN
    temp := get_json_value(obj, path, base);
    if(coalesce(temp::text, '') = '' or not temp.is_bool) then
      return null;
    else
      return temp.get_bool;
    end if;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.get_date (obj json, path text, base bigint default 1)  RETURNS timestamp AS $body$
DECLARE

    temp json_value;
  
BEGIN
    temp := get_json_value(obj, path, base);
    if(coalesce(temp::text, '') = '' or not is_date(temp)) then
      return null;
    else
      return json_ext.to_date2(temp);
    end if;
  end;

  /* JSON Path putter internal function */

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.put_internal (obj in out nocopy json, v_path text, elem json_value, base bigint)  RETURNS nocopy AS $body$
DECLARE

    val json_value := elem;
    path json_list;
    backreference json_list := json_list();

    keyval json_value; keynum bigint; keystring varchar(4000);
    temp json_value := obj.to_json_value;
    obj_temp  json;
    list_temp json_list;
    inserter json_value;
  
BEGIN
    path := json_ext.parsePath(v_path, base);
    if(path.count = 0) then RAISE EXCEPTION 'JSON_EXT put error: cannot put with empty string.'; end if;

    --build backreference
    FOR i in 1 .. path.count loop
      --backreference.print(false);
      keyval := path.get(i);
      if (keyval.is_number()) then
        --nummer index
        keynum := keyval.get_number();
        if((not temp.is_object()) and (not temp.is_array())) then
          if(coalesce(val::text, '') = '') then return; end if;
          backreference.remove_last;
          temp := json_list().to_json_value();
          backreference.append(temp);
        end if;

        if(temp.is_object()) then
          obj_temp := json(temp);
          if(obj_temp.count < keynum) then
            if(coalesce(val::text, '') = '') then return; end if;
            RAISE EXCEPTION 'JSON_EXT put error: access object with to few members.';
          end if;
          temp := obj_temp.get(keynum);
        else
          list_temp := json_list(temp);
          if(list_temp.count < keynum) then
            if(coalesce(val::text, '') = '') then return; end if;
            --raise error or quit if val is null
            for i in list_temp.count+1 .. keynum loop
              list_temp.append(json_value.makenull);
            end loop;
            backreference.remove_last;
            backreference.append(list_temp);
          end if;

          temp := list_temp.get(keynum);
        end if;
      else
        --streng index
        keystring := keyval.get_string();
        if(not temp.is_object()) then
          --backreference.print;
          if(coalesce(val::text, '') = '') then return; end if;
          backreference.remove_last;
          temp := json().to_json_value();
          backreference.append(temp);
          --raise_application_error(-20110, 'JSON_ext put error: trying to access a non object with a string.');
        end if;
        obj_temp := json(temp);
        temp := obj_temp.get(keystring);
      end if;

      if(coalesce(temp::text, '') = '') then
        if(coalesce(val::text, '') = '') then return; end if;
        --what to expect?
        keyval := path.get(i+1);
        if((keyval IS NOT NULL AND keyval::text <> '') and keyval.is_number()) then
          temp := json_list().to_json_value;
        else
          temp := json().to_json_value;
        end if;
      end if;
      backreference.append(temp);
    end loop;

  --  backreference.print(false);
  --  path.print(false);

    --use backreference and path together
    inserter := val;
    for i IN REVERSE backreference.count..1 loop
  --    inserter.print(false);
      if( i = 1 ) then
        keyval := path.get(1);
        if(keyval.is_string()) then
          keystring := keyval.get_string();
        else
          keynum := keyval.get_number();
          declare
            t1 json_value := obj.get(keynum);
          begin
            keystring := t1.mapname;
          end;
        end if;
        if(coalesce(inserter::text, '') = '') then obj.remove(keystring); else obj.put(keystring, inserter); end if;
      else
        temp := backreference.get(i-1);
        if(temp.is_object()) then
          keyval := path.get(i);
          obj_temp := json(temp);
          if(keyval.is_string()) then
            keystring := keyval.get_string();
          else
            keynum := keyval.get_number();
            declare
              t1 json_value := obj_temp.get(keynum);
            begin
              keystring := t1.mapname;
            end;
          end if;
          if(coalesce(inserter::text, '') = '') then
            obj_temp.remove(keystring);
            if(obj_temp.count > 0) then inserter := obj_temp.to_json_value; end if;
          else
            obj_temp.put(keystring, inserter);
            inserter := obj_temp.to_json_value;
          end if;
        else
          --array only number
          keynum := path.get(i).get_number();
          list_temp := json_list(temp);
          list_temp.remove(keynum);
          if(not coalesce(inserter::text, '') = '') then
            list_temp.append(inserter, keynum);
            inserter := list_temp.to_json_value;
          else
            if(list_temp.count > 0) then inserter := list_temp.to_json_value; end if;
          end if;
        end if;
      end if;

    end loop;

  END;

$body$
LANGUAGE PLPGSQL;


  /* JSON Path putters */


CREATE OR REPLACE FUNCTION json_ext.put (obj in out nocopy json, path text, elem text, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN
    put_internal(obj, path, json_value(elem), base);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.put (obj in out nocopy json, path text, elem bigint, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN
    if(coalesce(elem::text, '') = '') then RAISE EXCEPTION 'Cannot put null-value'; end if;
    put_internal(obj, path, json_value(elem), base);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.put (obj in out nocopy json, path text, elem json, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN
    if(coalesce(elem::text, '') = '') then RAISE EXCEPTION 'Cannot put null-value'; end if;
    put_internal(obj, path, elem.to_json_value, base);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.put (obj in out nocopy json, path text, elem json_list, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN
    if(coalesce(elem::text, '') = '') then RAISE EXCEPTION 'Cannot put null-value'; end if;
    put_internal(obj, path, elem.to_json_value, base);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.put (obj in out nocopy json, path text, elem boolean, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN
    if(coalesce(elem::text, '') = '') then RAISE EXCEPTION 'Cannot put null-value'; end if;
    put_internal(obj, path, json_value(elem), base);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.put (obj in out nocopy json, path text, elem json_value, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN
    if(coalesce(elem::text, '') = '') then RAISE EXCEPTION 'Cannot put null-value'; end if;
    put_internal(obj, path, elem, base);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.put (obj in out nocopy json, path text, elem timestamp, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN
    if(coalesce(elem::text, '') = '') then RAISE EXCEPTION 'Cannot put null-value'; end if;
    put_internal(obj, path, json_ext.to_json_value(elem), base);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_ext.remove (obj in out nocopy json, path text, base bigint default 1)  RETURNS nocopy AS $body$
BEGIN
    json_ext.put_internal(obj,path,null,base);
--    if(json_ext.get_json_value(obj,path) is not null) then
--    end if;
  END;

$body$
LANGUAGE PLPGSQL;


    --Pretty print with JSON Path


CREATE OR REPLACE FUNCTION json_ext.pp (obj json, v_path text)  RETURNS varchar AS $body$
DECLARE

    json_part json_value;
  
BEGIN
    json_part := json_ext.get_json_value(obj, v_path);
    if(coalesce(json_part::text, '') = '') then
      return '';
    else
      return json_printer.pretty_print_any(json_part); --escapes a possible internal string
    end if;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION json_ext.pp (obj json, v_path text)  RETURNS VOID AS $body$
DECLARE
 --using dbms_output.put_line
  
BEGIN
    RAISE NOTICE '%', pp(obj, v_path);
  END;

$body$
LANGUAGE PLPGSQL;


  -- spaces = false!


CREATE OR REPLACE FUNCTION json_ext.pp_htp (obj json, v_path text)  RETURNS VOID AS $body$
DECLARE
 --using htp.print
    json_part json_value;
  
BEGIN
    json_part := json_ext.get_json_value(obj, v_path);
    if(coalesce(json_part::text, '') = '') then htp.print; else
      htp.print(json_printer.pretty_print_any(json_part, false));
    end if;
  END;

$body$
LANGUAGE PLPGSQL;

    obj json_list := json_list();
    c text := empty_clob();
    benc bytea;

    v_blob_offset bigint := 1;
    v_clob_offset bigint := 1;
    v_lang_context bigint := DBMS_LOB.DEFAULT_LANG_CTX;
    v_warning bigint;
    v_amount integer;
--    temp varchar2(32767);



CREATE OR REPLACE FUNCTION json_ext.encodeblob2base64 (pBlobIn IN bytea)  RETURNS bytea AS $body$
DECLARE

      vAmount bigint := 45;
      vBlobEnc bytea := empty_blob)|%;
      vBlobEncLen bigint := 0;
      vBlobInLen bigint := 0;
      vBuffer bytea(45);
      vOffset bigint := 1;
    
BEGIN
--      dbms_output.put_line('Start base64 encoding.');
      vBlobInLen := dbms_lob.getlength(pBlobIn);
--      dbms_output.put_line('<BlobInLength>' || vBlobInLen);
      dbms_lob.createtemporary(vBlobEnc, TRUE);
      LOOP
        IF vOffset >= vBlobInLen THEN
          EXIT;
        END IF;
        dbms_lob.read(pBlobIn, vAmount, vOffset, vBuffer);
        BEGIN
          dbms_lob.append(vBlobEnc, utl_encode.base64_encode(vBuffer));
        EXCEPTION
          WHEN OTHERS THEN
          RAISE NOTICE '%%%%%%', '<vAmount>' ,  vAmount ,  '<vOffset>' ,  vOffset ,  '<vBuffer>' ,  vBuffer;
          RAISE NOTICE '%%', 'ERROR IN append: ' ,  SQLERRM;
          RAISE;
        END;
        vOffset := vOffset + vAmount;
      END LOOP;
      vBlobEncLen := dbms_lob.getlength(vBlobEnc);
--      dbms_output.put_line('<BlobEncLength>' || vBlobEncLen);
--      dbms_output.put_line('Finshed base64 encoding.');
      RETURN vBlobEnc;
    END;

$body$
LANGUAGE PLPGSQL;
  begin
    benc := encodeBlob2Base64(binarydata);
    dbms_lob.createtemporary(c, TRUE);
    v_amount := DBMS_LOB.GETLENGTH(benc);
    DBMS_LOB.CONVERTTOCLOB(c, benc, v_amount, v_clob_offset, v_blob_offset, 1, v_lang_context, v_warning);

    v_amount := DBMS_LOB.GETLENGTH(c);
    v_clob_offset := 1;
    --dbms_output.put_line('V amount: '||v_amount);
    while(v_clob_offset < v_amount) loop
      --dbms_output.put_line(v_offset);
      --temp := ;
      --dbms_output.put_line('size: '||length(temp));
      obj.append(dbms_lob.SUBSTR(c, 4000,v_clob_offset));
      v_clob_offset := v_clob_offset + 4000;
    end loop;
    dbms_lob.freetemporary(benc);
    dbms_lob.freetemporary(c);
  --dbms_output.put_line(obj.count);
  --dbms_output.put_line(obj.get_last().to_char);
    return obj;

  END;



FUNCTION base64 (l json_list) return blob as
    c clob := empty_clob();
    b blob := empty_blob();
    bret blob;

    v_blob_offset NUMBER := 1;
    v_clob_offset NUMBER := 1;
    v_lang_context NUMBER := 0; --DBMS_LOB.DEFAULT_LANG_CTX;
    v_warning NUMBER;
    v_amount PLS_INTEGER;



CREATE OR REPLACE FUNCTION json_ext.decodebase642blob (pBlobIn IN bytea)  RETURNS bytea AS $body$
DECLARE

      vAmount bigint := 256;--32;
      vBlobDec bytea := empty_blob)|%;
      vBlobDecLen bigint := 0;
      vBlobInLen bigint := 0;
      vBuffer bytea(256);--32);
      vOffset bigint := 1;
    
BEGIN
--      dbms_output.put_line('Start base64 decoding.');
      vBlobInLen := dbms_lob.getlength(pBlobIn);
--      dbms_output.put_line('<BlobInLength>' || vBlobInLen);
      dbms_lob.createtemporary(vBlobDec, TRUE);
      LOOP
        IF vOffset >= vBlobInLen THEN
          EXIT;
        END IF;
        dbms_lob.read(pBlobIn, vAmount, vOffset, vBuffer);
        BEGIN
          dbms_lob.append(vBlobDec, utl_encode.base64_decode(vBuffer));
        EXCEPTION
          WHEN OTHERS THEN
          RAISE NOTICE '%%%%%%', '<vAmount>' ,  vAmount ,  '<vOffset>' ,  vOffset ,  '<vBuffer>' ,  vBuffer;
          RAISE NOTICE '%%', 'ERROR IN append: ' ,  SQLERRM;
          RAISE;
        END;
        vOffset := vOffset + vAmount;
      END LOOP;
      vBlobDecLen := dbms_lob.getlength(vBlobDec);
--      dbms_output.put_line('<BlobDecLength>' || vBlobDecLen);
--      dbms_output.put_line('Finshed base64 decoding.');
      RETURN vBlobDec;
    END;

$body$
LANGUAGE PLPGSQL;
  begin
    dbms_lob.createtemporary(c, TRUE);
    for i in 1 .. l.count loop
      dbms_lob.append(c, l.get(i).get_string());
    end loop;
    v_amount := DBMS_LOB.GETLENGTH(c);
--    dbms_output.put_line('L C'||v_amount);

    dbms_lob.createtemporary(b, TRUE);
    DBMS_LOB.CONVERTTOBLOB(b, c, dbms_lob.lobmaxsize, v_clob_offset, v_blob_offset, 1, v_lang_context, v_warning);
    dbms_lob.freetemporary(c);
    v_amount := DBMS_LOB.GETLENGTH(b);
--    dbms_output.put_line('L B'||v_amount);

    bret := decodeBase642Blob(b);
    dbms_lob.freetemporary(b);
    return bret;

  END;


FUNCTION encode (binarydata blob) return json_value as
    obj json_value;
    c clob := empty_clob();
    benc blob;

    v_blob_offset NUMBER := 1;
    v_clob_offset NUMBER := 1;
    v_lang_context NUMBER := DBMS_LOB.DEFAULT_LANG_CTX;
    v_warning NUMBER;
    v_amount PLS_INTEGER;
--    temp varchar2(32767);



CREATE OR REPLACE FUNCTION json_ext.encodeblob2base64 (pBlobIn IN bytea)  RETURNS bytea AS $body$
DECLARE

      vAmount bigint := 45;
      vBlobEnc bytea := empty_blob)|%;
      vBlobEncLen bigint := 0;
      vBlobInLen bigint := 0;
      vBuffer bytea(45);
      vOffset bigint := 1;
    
BEGIN
--      dbms_output.put_line('Start base64 encoding.');
      vBlobInLen := dbms_lob.getlength(pBlobIn);
--      dbms_output.put_line('<BlobInLength>' || vBlobInLen);
      dbms_lob.createtemporary(vBlobEnc, TRUE);
      LOOP
        IF vOffset >= vBlobInLen THEN
          EXIT;
        END IF;
        dbms_lob.read(pBlobIn, vAmount, vOffset, vBuffer);
        BEGIN
          dbms_lob.append(vBlobEnc, utl_encode.base64_encode(vBuffer));
        EXCEPTION
          WHEN OTHERS THEN
          RAISE NOTICE '%%%%%%', '<vAmount>' ,  vAmount ,  '<vOffset>' ,  vOffset ,  '<vBuffer>' ,  vBuffer;
          RAISE NOTICE '%%', 'ERROR IN append: ' ,  SQLERRM;
          RAISE;
        END;
        vOffset := vOffset + vAmount;
      END LOOP;
      vBlobEncLen := dbms_lob.getlength(vBlobEnc);
--      dbms_output.put_line('<BlobEncLength>' || vBlobEncLen);
--      dbms_output.put_line('Finshed base64 encoding.');
      RETURN vBlobEnc;
    END;

$body$
LANGUAGE PLPGSQL;
  begin
    benc := encodeBlob2Base64(binarydata);
    dbms_lob.createtemporary(c, TRUE);
    v_amount := DBMS_LOB.GETLENGTH(benc);
    DBMS_LOB.CONVERTTOCLOB(c, benc, v_amount, v_clob_offset, v_blob_offset, 1, v_lang_context, v_warning);

    obj := json_value(c);

    dbms_lob.freetemporary(benc);
    dbms_lob.freetemporary(c);
  --dbms_output.put_line(obj.count);
  --dbms_output.put_line(obj.get_last().to_char);
    return obj;

  END;


FUNCTION decode (v json_value) return blob as
    c clob := empty_clob();
    b blob := empty_blob();
    bret blob;

    v_blob_offset NUMBER := 1;
    v_clob_offset NUMBER := 1;
    v_lang_context NUMBER := 0; --DBMS_LOB.DEFAULT_LANG_CTX;
    v_warning NUMBER;
    v_amount PLS_INTEGER;



CREATE OR REPLACE FUNCTION json_ext.decodebase642blob (pBlobIn IN bytea)  RETURNS bytea AS $body$
DECLARE

      vAmount bigint := 256;--32;
      vBlobDec bytea := empty_blob)|%;
      vBlobDecLen bigint := 0;
      vBlobInLen bigint := 0;
      vBuffer bytea(256);--32);
      vOffset bigint := 1;
    
BEGIN
--      dbms_output.put_line('Start base64 decoding.');
      vBlobInLen := dbms_lob.getlength(pBlobIn);
--      dbms_output.put_line('<BlobInLength>' || vBlobInLen);
      dbms_lob.createtemporary(vBlobDec, TRUE);
      LOOP
        IF vOffset >= vBlobInLen THEN
          EXIT;
        END IF;
        dbms_lob.read(pBlobIn, vAmount, vOffset, vBuffer);
        BEGIN
          dbms_lob.append(vBlobDec, utl_encode.base64_decode(vBuffer));
        EXCEPTION
          WHEN OTHERS THEN
          RAISE NOTICE '%%%%%%', '<vAmount>' ,  vAmount ,  '<vOffset>' ,  vOffset ,  '<vBuffer>' ,  vBuffer;
          RAISE NOTICE '%%', 'ERROR IN append: ' ,  SQLERRM;
          RAISE;
        END;
        vOffset := vOffset + vAmount;
      END LOOP;
      vBlobDecLen := dbms_lob.getlength(vBlobDec);
--      dbms_output.put_line('<BlobDecLength>' || vBlobDecLen);
--      dbms_output.put_line('Finshed base64 decoding.');
      RETURN vBlobDec;
    END;

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'JSON_EXT' declaration

-- Oracle package 'JSON_HELPER' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS json_helper CASCADE;
CREATE SCHEMA json_helper;

--recursive merge


CREATE OR REPLACE FUNCTION json_helper.merge ( p_a_json json, p_b_json json)  RETURNS json AS $body$
DECLARE

    l_json    JSON;
    l_jv      json_value;
    l_indx    bigint;
    l_recursive json_value;
  
BEGIN
    --
    -- Initialize our return object
    --
    l_json := p_a_json;

    -- loop through p_b_json
    l_indx := p_b_json.json_data.first;
    loop
      exit when coalesce(l_indx::text, '') = '';
      l_jv   := p_b_json.json_data(l_indx);
      if(l_jv.is_object) then
        --recursive
        l_recursive := l_json.get(l_jv.mapname);
        if((l_recursive IS NOT NULL AND l_recursive::text <> '') and l_recursive.is_object) then
          l_json.put(l_jv.mapname, merge(json(l_recursive), json(l_jv)));
        else
          l_json.put(l_jv.mapname, l_jv);
        end if;
      else
        l_json.put(l_jv.mapname, l_jv);
      end if;

      --increment
      l_indx := p_b_json.json_data.next(l_indx);
    end loop;

    return l_json;

  END;

$body$
LANGUAGE PLPGSQL;


  -- join two lists


CREATE OR REPLACE FUNCTION json_helper.join ( p_a_list json_list, p_b_list json_list)  RETURNS json_list AS $body$
DECLARE

    l_json_list json_list := p_a_list;
  
BEGIN
    for indx in 1 .. p_b_list.count loop
      l_json_list.append(p_b_list.get(indx));
    end loop;

    return l_json_list;

  END;

$body$
LANGUAGE PLPGSQL;


  -- keep keys.


CREATE OR REPLACE FUNCTION json_helper.keep ( p_json json, p_keys json_list)  RETURNS json AS $body$
DECLARE

    l_json json := json();
    mapname varchar(4000);
  
BEGIN
    for i in 1 .. p_keys.count loop
      mapname := p_keys.get(i).get_string;
      if(p_json.exist(mapname)) then
        l_json.put(mapname, p_json.get(mapname));
      end if;
    end loop;

    return l_json;
  END;

$body$
LANGUAGE PLPGSQL;


  -- drop keys.


CREATE OR REPLACE FUNCTION json_helper.remove ( p_json json, p_keys json_list)  RETURNS json AS $body$
DECLARE

    l_json json := p_json;
  
BEGIN
    for i in 1 .. p_keys.count loop
      l_json.remove(p_keys.get(i).get_string);
    end loop;

    return l_json;
  END;

$body$
LANGUAGE PLPGSQL;


  --equals functions



CREATE OR REPLACE FUNCTION json_helper.equals (p_v1 json_value, p_v2 bigint)  RETURNS boolean AS $body$
BEGIN
    if(coalesce(p_v2::text, '') = '') then
      return p_v1.is_null;
    end if;

    if(not p_v1.is_number) then
      return false;
    end if;

    return p_v2 = p_v1.get_number;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.equals (p_v1 json_value, p_v2 boolean)  RETURNS boolean AS $body$
BEGIN
    if(coalesce(p_v2::text, '') = '') then
      return p_v1.is_null;
    end if;

    if(not p_v1.is_bool) then
      return false;
    end if;

    return p_v2 = p_v1.get_bool;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.equals (p_v1 json_value, p_v2 text)  RETURNS boolean AS $body$
BEGIN
    if(coalesce(p_v2::text, '') = '') then
      return p_v1.is_null;
    end if;

    if(not p_v1.is_string) then
      return false;
    end if;

    return p_v2 = p_v1.get_string;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.equals (p_v1 json_value, p_v2 text)  RETURNS boolean AS $body$
DECLARE

    my_clob text;
    res boolean;
  
BEGIN
    if(coalesce(p_v2::text, '') = '') then
      return p_v1.is_null;
    end if;

    if(not p_v1.is_string) then
      return false;
    end if;

    my_clob := empty_clob();
    dbms_lob.createtemporary(my_clob, true);
    p_v1.get_string(my_clob);

    res := dbms_lob.compare(p_v2, my_clob) = 0;
    dbms_lob.freetemporary(my_clob);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.equals (p_v1 json_value, p_v2 json_value, exact boolean)  RETURNS boolean AS $body$
BEGIN
    if(coalesce(p_v2::text, '') = '') then
      return p_v1.is_null;
    end if;

    if(p_v2.is_number) then return equals(p_v1, p_v2.get_number); end if;
    if(p_v2.is_bool) then return equals(p_v1, p_v2.get_bool); end if;
    if(p_v2.is_object) then return equals(p_v1, json(p_v2), exact); end if;
    if(p_v2.is_array) then return equals(p_v1, json_list(p_v2), exact); end if;
    if(p_v2.is_string) then
      if(coalesce(p_v2.extended_str::text, '') = '') then
        return equals(p_v1, p_v2.get_string);
      else
        declare
          my_clob text; res boolean;
        begin
          my_clob := empty_clob();
          dbms_lob.createtemporary(my_clob, true);
          p_v2.get_string(my_clob);
          res := equals(p_v1, my_clob);
          dbms_lob.freetemporary(my_clob);
          return res;
        end;
      end if;
    end if;

    return false; --should never happen
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.equals (p_v1 json_value, p_v2 json_list, exact boolean)  RETURNS boolean AS $body$
DECLARE

    cmp json_list;
    res boolean := true;
  
BEGIN
--  p_v1.print(false);
--  p_v2.print(false);
--  dbms_output.put_line('labc1'||case when exact then 'X' else 'U' end);

    if(coalesce(p_v2::text, '') = '') then
      return p_v1.is_null;
    end if;

    if(not p_v1.is_array) then
      return false;
    end if;

--  dbms_output.put_line('labc2'||case when exact then 'X' else 'U' end);

    cmp := json_list(p_v1);
    if(cmp.count != p_v2.count and exact) then return false; end if;

--  dbms_output.put_line('labc3'||case when exact then 'X' else 'U' end);

    if(exact) then
      for i in 1 .. cmp.count loop
        res := equals(cmp.get(i), p_v2.get(i), exact);
        if(not res) then return res; end if;
      end loop;
    else
--  dbms_output.put_line('labc4'||case when exact then 'X' else 'U' end);
      if(p_v2.count > cmp.count) then return false; end if;
--  dbms_output.put_line('labc5'||case when exact then 'X' else 'U' end);

      --match sublist here!
      for x in 0 .. (cmp.count-p_v2.count) loop
--  dbms_output.put_line('labc7'||x);

        for i in 1 .. p_v2.count loop
          res := equals(cmp.get(x+i), p_v2.get(i), exact);
          if(not res) then
            goto next_index;
          end if;
        end loop;
        return true;

        <<next_index>>
        null;
      end loop;

--  dbms_output.put_line('labc7'||case when exact then 'X' else 'U' end);

    return false; --no match

    end if;

    return res;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.equals (p_v1 json_value, p_v2 json, exact boolean)  RETURNS boolean AS $body$
DECLARE

    cmp json;
    res boolean := true;
  
BEGIN
--  p_v1.print(false);
--  p_v2.print(false);
--  dbms_output.put_line('abc1');

    if(coalesce(p_v2::text, '') = '') then
      return p_v1.is_null;
    end if;

    if(not p_v1.is_object) then
      return false;
    end if;

    cmp := json(p_v1);

--  dbms_output.put_line('abc2');

    if(cmp.count != p_v2.count and exact) then return false; end if;

--  dbms_output.put_line('abc3');
    declare
      k1 json_list := p_v2.get_keys;
      key_index numeric;
    begin
      for i in 1 .. k1.count loop
        key_index := cmp.index_of(k1.get(i).get_string);
        if(key_index = -1) then return false; end if;
        if(exact) then
          if(not equals(p_v2.get(i), cmp.get(key_index),true)) then return false; end if;
        else
          --non exact
          declare
            v1 json_value := cmp.get(key_index);
            v2 json_value := p_v2.get(i);
          begin
--  dbms_output.put_line('abc3 1/2');
--            v1.print(false);
--            v2.print(false);

            if(v1.is_object and v2.is_object) then
              if(not equals(v1, v2, false)) then return false; end if;
            elsif(v1.is_array and v2.is_array) then
              if(not equals(v1, v2, false)) then return false; end if;
            else
              if(not equals(v1, v2, true)) then return false; end if;
            end if;
          end;

        end if;
      end loop;
    end;

--  dbms_output.put_line('abc4');

    return true;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.equals (p_v1 json, p_v2 json, exact boolean)  RETURNS boolean AS $body$
BEGIN
    return equals(p_v1.to_json_value, p_v2, exact);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.equals (p_v1 json_list, p_v2 json_list, exact boolean)  RETURNS boolean AS $body$
BEGIN
    return equals(p_v1.to_json_value, p_v2, exact);
  end;

  --contain

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json, p_v2 json_value, exact boolean)  RETURNS boolean AS $body$
DECLARE

    v_values json_list;
  
BEGIN
    if(equals(p_v1.to_json_value, p_v2, exact)) then return true; end if;

    v_values := p_v1.get_values;

    for i in 1 .. v_values.count loop
      declare
        v_val json_value := v_values.get(i);
      begin
        if(v_val.is_object) then
          if(contains(json(v_val),p_v2,exact)) then return true; end if;
        end if;
        if(v_val.is_array) then
          if(contains(json_list(v_val),p_v2, exact)) then return true; end if;
        end if;

        if(equals(v_val, p_v2, exact)) then return true; end if;
      end;

    end loop;

    return false;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json_list, p_v2 json_value, exact boolean)  RETURNS boolean AS $body$
BEGIN
    if(equals(p_v1.to_json_value, p_v2, exact)) then return true; end if;

    for i in 1 .. p_v1.count loop
      declare
        v_val json_value := p_v1.get(i);
      begin
        if(v_val.is_object) then
          if(contains(json(v_val),p_v2, exact)) then return true; end if;
        end if;
        if(v_val.is_array) then
          if(contains(json_list(v_val),p_v2, exact)) then return true; end if;
        end if;

        if(equals(v_val, p_v2, exact)) then return true; end if;
      end;

    end loop;

    return false;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json, p_v2 json, exact boolean )  RETURNS boolean AS $body$
BEGIN return contains(p_v1, p_v2.to_json_value,exact); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json, p_v2 json_list, exact boolean )  RETURNS boolean AS $body$
BEGIN return contains(p_v1, p_v2.to_json_value,exact); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json, p_v2 bigint, exact boolean )  RETURNS boolean AS $body$
BEGIN
  return contains(p_v1, json_value(p_v2),exact); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json, p_v2 text, exact boolean )  RETURNS boolean AS $body$
BEGIN
  return contains(p_v1, json_value(p_v2),exact); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json, p_v2 boolean, exact boolean )  RETURNS boolean AS $body$
BEGIN
  return contains(p_v1, json_value(p_v2),exact); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json, p_v2 text, exact boolean )  RETURNS boolean AS $body$
BEGIN
  return contains(p_v1, json_value(p_v2),exact); end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json_list, p_v2 json, exact boolean )  RETURNS boolean AS $body$
BEGIN
  return contains(p_v1, p_v2.to_json_value,exact); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json_list, p_v2 json_list, exact boolean )  RETURNS boolean AS $body$
BEGIN
  return contains(p_v1, p_v2.to_json_value,exact); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json_list, p_v2 bigint, exact boolean )  RETURNS boolean AS $body$
BEGIN
  return contains(p_v1, json_value(p_v2),exact); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json_list, p_v2 text, exact boolean )  RETURNS boolean AS $body$
BEGIN
  return contains(p_v1, json_value(p_v2),exact); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json_list, p_v2 boolean, exact boolean )  RETURNS boolean AS $body$
BEGIN
  return contains(p_v1, json_value(p_v2),exact); end;

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_helper.contains (p_v1 json_list, p_v2 text, exact boolean )  RETURNS boolean AS $body$
BEGIN
  return contains(p_v1, json_value(p_v2),exact); end;

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'JSON_HELPER' declaration

-- Oracle package 'JSON_ML' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS json_ml CASCADE;
CREATE SCHEMA json_ml;




CREATE OR REPLACE FUNCTION json_ml.xml2json (xml in xml)  RETURNS json_list AS $body$
DECLARE

    l_json        xml;
    l_returnvalue text;
  
BEGIN
    l_json := xml.transform (get_jsonml_stylesheet);
    l_returnvalue := l_json.getclobval();
    l_returnvalue := dbms_xmlgen.convert (l_returnvalue, dbms_xmlgen.entity_decode);
    --dbms_output.put_line(l_returnvalue);
    return json_list(l_returnvalue);
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION json_ml.xmlstr2json (xmlstr in text)  RETURNS json_list AS $body$
BEGIN
    return xml2json(xml(xmlstr));
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION json_ml.get_jsonml_stylesheet () RETURNS xml AS $body$
BEGIN
    if(coalesce(jsonml_stylesheet::text, '') = '') then
    jsonml_stylesheet := xml('<?xml version="1.0" encoding="UTF-8"?>
<!--
		JsonML.xslt

		Created: 2006-11-15-0551
		Modified: 2009-02-14-0927

		Released under an open-source license:
		http://jsonml.org/License.htm

		This transformation converts any XML document into JsonML.
		It omits processing-instructions and comment-nodes.

		To enable comment-nodes to be emitted as JavaScript comments,
		uncomment the Comment() template.
-->
<xsl:stylesheet version="1.0"
				xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

	<xsl:output method="text"
				media-type="application/json"
				encoding="UTF-8"
				indent="no"
				omit-xml-declaration="yes" />

	<!-- constants -->
	<xsl:variable name="XHTML"
				  PERFORM="''http://www.w3.org/1999/xhtml''" />

	<xsl:variable name="START_ELEM"
				  PERFORM="''[''" />

	<xsl:variable name="END_ELEM"
				  PERFORM="'']''" />

	<xsl:variable name="VALUE_DELIM"
				  PERFORM="'',''" />

	<xsl:variable name="START_ATTRIB"
				  PERFORM="''{''" />

	<xsl:variable name="END_ATTRIB"
				  PERFORM="''}''" />

	<xsl:variable name="NAME_DELIM"
				  PERFORM="'':''" />

	<xsl:variable name="STRING_DELIM"
				  PERFORM="''&#x22;''" />

	<xsl:variable name="START_COMMENT"
				  PERFORM="''/*''" />

	<xsl:variable name="END_COMMENT"
				  select="''*/
''" />

	<!-- root-node -->
	<xsl:template match="/">
		<xsl:apply-templates select="*" />
	</xsl:template>

	<!-- comments -->
	<xsl:template match="comment()">
	<!-- uncomment to support JSON comments -->
	<!--
		<xsl:value-of select="$START_COMMENT" />

		<xsl:value-of select="."
					  disable-output-escaping="yes" />

		<xsl:value-of select="$END_COMMENT" />
	-->
	</xsl:template>

	<!-- elements -->
	<xsl:template match="*">
		<xsl:value-of select="$START_ELEM" />

		<!-- tag-name string -->
		<xsl:value-of select="$STRING_DELIM" />
		<xsl:choose>
			<xsl:when test="namespace-uri()=$XHTML">
				<xsl:value-of select="local-name()" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="name()" />
			</xsl:otherwise>
		</xsl:choose>
		<xsl:value-of select="$STRING_DELIM" />

		<!-- attribute object -->
		<xsl:if test="count(@*)>0">
			<xsl:value-of select="$VALUE_DELIM" />
			<xsl:value-of select="$START_ATTRIB" />
			<xsl:for-each select="@*">
				<xsl:if test="position()>1">
					<xsl:value-of select="$VALUE_DELIM" />
				</xsl:if>
				<xsl:apply-templates select="." />
			</xsl:for-each>
			<xsl:value-of select="$END_ATTRIB" />
		</xsl:if>

		<!-- child elements and text-nodes -->
		<xsl:for-each select="*|text()">
			<xsl:value-of select="$VALUE_DELIM" />
			<xsl:apply-templates select="." />
		</xsl:for-each>

		<xsl:value-of select="$END_ELEM" />
	</xsl:template>

	<!-- text-nodes -->
	<xsl:template match="text()">
		<xsl:call-template name="escape-string">
			<xsl:with-param name="value"
							PERFORM="." />
		</xsl:call-template>
	</xsl:template>

	<!-- attributes -->
	<xsl:template match="@*">
		<xsl:value-of select="$STRING_DELIM" />
		<xsl:choose>
			<xsl:when test="namespace-uri()=$XHTML">
				<xsl:value-of select="local-name()" />
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="name()" />
			</xsl:otherwise>
		</xsl:choose>
		<xsl:value-of select="$STRING_DELIM" />

		<xsl:value-of select="$NAME_DELIM" />

		<xsl:call-template name="escape-string">
			<xsl:with-param name="value"
							PERFORM="." />
		</xsl:call-template>

	</xsl:template>

	<!-- escape-string: quotes and escapes -->
	<xsl:template name="escape-string">
		<xsl:param name="value" />

		<xsl:value-of select="$STRING_DELIM" />

		<xsl:if test="string-length($value)>0">
			<xsl:variable name="escaped-whacks">
				<!-- escape backslashes -->
				<xsl:call-template name="string-replace">
					<xsl:with-param name="value"
									PERFORM="$value" />
					<xsl:with-param name="find"
									PERFORM="''\''" />
					<xsl:with-param name="replace"
									PERFORM="''\\''" />
				</xsl:call-template>
			</xsl:variable>

			<xsl:variable name="escaped-LF">
				<!-- escape line feeds -->
				<xsl:call-template name="string-replace">
					<xsl:with-param name="value"
									PERFORM="$escaped-whacks" />
					<xsl:with-param name="find"
									PERFORM="''&#x0A;''" />
					<xsl:with-param name="replace"
									PERFORM="''\n''" />
				</xsl:call-template>
			</xsl:variable>

			<xsl:variable name="escaped-CR">
				<!-- escape carriage returns -->
				<xsl:call-template name="string-replace">
					<xsl:with-param name="value"
									PERFORM="$escaped-LF" />
					<xsl:with-param name="find"
									PERFORM="''&#x0D;''" />
					<xsl:with-param name="replace"
									PERFORM="''\r''" />
				</xsl:call-template>
			</xsl:variable>

			<xsl:variable name="escaped-tabs">
				<!-- escape tabs -->
				<xsl:call-template name="string-replace">
					<xsl:with-param name="value"
									PERFORM="$escaped-CR" />
					<xsl:with-param name="find"
									PERFORM="''&#x09;''" />
					<xsl:with-param name="replace"
									PERFORM="''\t''" />
				</xsl:call-template>
			</xsl:variable>

			<!-- escape quotes -->
			<xsl:call-template name="string-replace">
				<xsl:with-param name="value"
								PERFORM="$escaped-tabs" />
				<xsl:with-param name="find"
								PERFORM="''&quot;''" />
				<xsl:with-param name="replace"
								PERFORM="''\&quot;''" />
			</xsl:call-template>
		</xsl:if>

		<xsl:value-of select="$STRING_DELIM" />
	</xsl:template>

	<!-- string-replace: replaces occurances of one string with another -->
	<xsl:template name="string-replace">
		<xsl:param name="value" />
		<xsl:param name="find" />
		<xsl:param name="replace" />

		<xsl:choose>
			<xsl:when test="contains($value,$find)">
				<!-- replace and call recursively on next -->
				<xsl:value-of select="substring-before($value,$find)"
							  disable-output-escaping="yes" />
				<xsl:value-of select="$replace"
							  disable-output-escaping="yes" />
				<xsl:call-template name="string-replace">
					<xsl:with-param name="value"
									PERFORM="substring-after($value,$find)" />
					<xsl:with-param name="find"
									PERFORM="$find" />
					<xsl:with-param name="replace"
									PERFORM="$replace" />
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<!-- no replacement necessary -->
				<xsl:value-of select="$value"
							  disable-output-escaping="yes" />
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

</xsl:stylesheet>');
    end if;
    return jsonml_stylesheet;
  END;

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'JSON_ML' declaration

-- Oracle package 'JSON_PARSER' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS JSON_PARSER CASCADE;
CREATE SCHEMA JSON_PARSER;

/*
  Copyright (c) 2009 Jonas Krogsboell

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
  */

  decimalpoint varchar2(1 char) := '.';



CREATE OR REPLACE FUNCTION JSON_PARSER.updatedecimalpoint () RETURNS VOID AS $body$
BEGIN
    SELECT substring(VALUE from 1 for 1) into decimalpoint FROM NLS_SESSION_PARAMETERS WHERE PARAMETER = 'NLS_NUMERIC_CHARACTERS';
  END;

$body$
LANGUAGE PLPGSQL;


  /*type json_src is record (len number, offset number, src varchar2(10), s_clob clob); */


CREATE OR REPLACE FUNCTION JSON_PARSER.next_char (indx bigint, s in out nocopy json_src)  RETURNS varchar AS $body$
BEGIN
    if(indx > s.len) then return null; end if;
    --right offset?
    if(indx > 4000 + s.offset or indx < s.offset) then
    --load right offset
      s.offset := indx - (indx mod 4000);
      s.src := dbms_lob.substring(s.s_clob from 4000 for s.offset+1);
    end if;
    --read from s.src
    return substring(s.src from indx-s.offset for 1);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PARSER.next_char2 (indx bigint, s in out nocopy json_src, amount bigint default 1)  RETURNS varchar AS $body$
DECLARE

    buf varchar(32767) := '';
  
BEGIN
    for i in 1..amount loop
      buf := buf || next_char(indx-1+i,s);
    end loop;
    return buf;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PARSER.prepareclob (buf text)  RETURNS json_parser.json_src AS $body$
DECLARE

    temp json_parser.json_src;
  
BEGIN
    temp.s_clob := buf;
    temp.offset := 0;
    temp.src := dbms_lob.substring(buf from 4000 for temp.offset+1);
    temp.len := dbms_lob.getlength(buf);
    return temp;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PARSER.preparevarchar2 (buf text)  RETURNS json_parser.json_src AS $body$
DECLARE

    temp json_parser.json_src;
  
BEGIN
    temp.s_clob := buf;
    temp.offset := 0;
    temp.src := substring(buf from 1 for 4000);
    temp.len := length(buf);
    return temp;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PARSER.debug (text text)  RETURNS VOID AS $body$
BEGIN
    RAISE NOTICE '%', text;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PARSER.print_token (t rToken)  RETURNS VOID AS $body$
BEGIN
    RAISE NOTICE 'Line: % - Column: % - Type: % - Content: %', t.line, t.col, t.type_name, t.data;
  END;

$body$
LANGUAGE PLPGSQL;


  /* SCANNER FUNCTIONS START */


CREATE OR REPLACE FUNCTION JSON_PARSER.s_error (text text, line bigint, col bigint)  RETURNS VOID AS $body$
BEGIN
    RAISE EXCEPTION 'JSON Scanner exception @ line: % column: % - %',line,col,text;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PARSER.s_error (text text, tok rToken)  RETURNS VOID AS $body$
BEGIN
    RAISE EXCEPTION 'JSON Scanner exception @ line: % column: % - %',tok.line,tok.col,text;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PARSER.mt (t text, l pls_integer, c pls_integer, d text)  RETURNS rToken AS $body$
DECLARE

    token rToken;
  
BEGIN
    token.type_name := t;
    token.line := l;
    token.col := c;
    token.data := d;
    return token;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PARSER.lexnumber (jsrc in out nocopy json_src, tok in out nocopy rToken, indx in out nocopy pls_integer)  RETURNS integer AS $body$
DECLARE

    numbuf varchar(4000) := '';
    buf varchar(4);
    checkLoop boolean;
  
BEGIN
    buf := next_char(indx, jsrc);
    if(buf = '-') then numbuf := '-'; indx := indx + 1; end if;
    buf := next_char(indx, jsrc);
    --0 or [1-9]([0-9])*
    if(buf = '0') then
      numbuf := numbuf || '0'; indx := indx + 1;
      buf := next_char(indx, jsrc);
    elsif(buf >= '1' and buf <= '9') then
      numbuf := numbuf || buf; indx := indx + 1;
      --read digits
      buf := next_char(indx, jsrc);
      while(buf >= '0' and buf <= '9') loop
        numbuf := numbuf || buf; indx := indx + 1;
        buf := next_char(indx, jsrc);
      end loop;
    end if;
    --fraction
    if(buf = '.') then
      numbuf := numbuf || buf; indx := indx + 1;
      buf := next_char(indx, jsrc);
      checkLoop := FALSE;
      while(buf >= '0' and buf <= '9') loop
        checkLoop := TRUE;
        numbuf := numbuf || buf; indx := indx + 1;
        buf := next_char(indx, jsrc);
      end loop;
      if(not checkLoop) then
        s_error('Expected: digits in fraction', tok);
      end if;
    end if;
    --exp part
    if(buf in ('e', 'E')) then
      numbuf := numbuf || buf; indx := indx + 1;
      buf := next_char(indx, jsrc);
      if(buf = '+' or buf = '-') then
        numbuf := numbuf || buf; indx := indx + 1;
        buf := next_char(indx, jsrc);
      end if;
      checkLoop := FALSE;
      while(buf >= '0' and buf <= '9') loop
        checkLoop := TRUE;
        numbuf := numbuf || buf; indx := indx + 1;
        buf := next_char(indx, jsrc);
      end loop;
      if(not checkLoop) then
        s_error('Expected: digits in exp', tok);
      end if;
    end if;

    tok.data := numbuf;
    return indx;
  END;

$body$
LANGUAGE PLPGSQL;


  -- [a-zA-Z]([a-zA-Z0-9])*


CREATE OR REPLACE FUNCTION JSON_PARSER.lexname (jsrc in out nocopy json_src, tok in out nocopy rToken, indx in out nocopy pls_integer)  RETURNS integer AS $body$
DECLARE

    varbuf varchar(32767) := '';
    buf varchar(4);
    num bigint;
  
BEGIN
    buf := next_char(indx, jsrc);
    while(REGEXP_LIKE(buf, '^[[alnum:]\_]$', 'i')) loop
      varbuf := varbuf || buf;
      indx := indx + 1;
      buf := next_char(indx, jsrc);
      if (coalesce(buf::text, '') = '') then
        goto retname;
        --debug('Premature string ending');
      end if;
    end loop;
    <<retname>>

    --could check for reserved keywords here

    --debug(varbuf);
    tok.data := varbuf;
    return indx-1;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PARSER.updateclob (v_extended in out nocopy text, v_str text)  RETURNS nocopy AS $body$
BEGIN
    dbms_lob.writeappend(v_extended, length(v_str), v_str);
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PARSER.lexstring (jsrc in out nocopy json_src, tok in out nocopy rToken, indx in out nocopy pls_integer, endChar char)  RETURNS integer AS $body$
DECLARE

    v_extended text := null; v_count bigint := 0;
    varbuf varchar(32767) := '';
    buf varchar(4);
    wrong boolean;
  
BEGIN
    indx := indx +1;
    buf := next_char(indx, jsrc);
    while(buf != endChar) loop
      --clob control
      if(v_count > 8191) then --crazy oracle error (16383 is the highest working length with unistr - 8192 choosen to be safe)
        if(coalesce(v_extended::text, '') = '') then
          v_extended := empty_clob();
          dbms_lob.createtemporary(v_extended, true);
        end if;
        updateClob(v_extended, unistr(varbuf));
        varbuf := ''; v_count := 0;
      end if;
      if(buf = Chr(13) or buf = CHR(9) or buf = CHR(10)) then
        s_error('Control characters not allowed (CHR(9),CHR(10)CHR(13))', tok);
      end if;
      if(buf = '\') then
        --varbuf := varbuf || buf;
        indx := indx + 1;
        buf := next_char(indx, jsrc);
        case
          when buf in ('\') then
            varbuf := varbuf || buf || buf; v_count := v_count + 2;
            indx := indx + 1;
            buf := next_char(indx, jsrc);
          when buf in ('"', '/') then
            varbuf := varbuf || buf; v_count := v_count + 1;
            indx := indx + 1;
            buf := next_char(indx, jsrc);
          when buf = '''' then
            if(json_strict = false) then
              varbuf := varbuf || buf; v_count := v_count + 1;
              indx := indx + 1;
              buf := next_char(indx, jsrc);
            else
              s_error('strictmode - expected: " \ / b f n r t u ', tok);
            end if;
          when buf in ('b', 'f', 'n', 'r', 't') then
            --backspace b = U+0008
            --formfeed  f = U+000C
            --newline   n = U+000A
            --carret    r = U+000D
            --tabulator t = U+0009
            case buf
            when 'b' then varbuf := varbuf || chr(8);
            when 'f' then varbuf := varbuf || chr(13);
            when 'n' then varbuf := varbuf || chr(10);
            when 'r' then varbuf := varbuf || chr(14);
            when 't' then varbuf := varbuf || chr(9);
            end case;
            --varbuf := varbuf || buf;
            v_count := v_count + 1;
            indx := indx + 1;
            buf := next_char(indx, jsrc);
          when buf = 'u' then
            --four hexidecimal chars
            declare
              four varchar(4);
            begin
              four := next_char2(indx+1, jsrc, 4);
              wrong := FALSE;
              if(upper(substring(four from 1 for 1)) not in ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f')) then wrong := TRUE; end if;
              if(upper(substring(four from 2 for 1)) not in ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f')) then wrong := TRUE; end if;
              if(upper(substring(four from 3 for 1)) not in ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f')) then wrong := TRUE; end if;
              if(upper(substring(four from 4 for 1)) not in ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f')) then wrong := TRUE; end if;
              if(wrong) then
                s_error('expected: " \u([0-9][A-F]){4}', tok);
              end if;
--              varbuf := varbuf || buf || four;
              varbuf := varbuf || '\'||four;--chr(to_number(four,'XXXX'));
               v_count := v_count + 5;
              indx := indx + 5;
              buf := next_char(indx, jsrc);
              end;
          else
            s_error('expected: " \ / b f n r t u ', tok);
        end case;
      else
        varbuf := varbuf || buf; v_count := v_count + 1;
        indx := indx + 1;
        buf := next_char(indx, jsrc);
      end if;
    end loop;

    if (coalesce(buf::text, '') = '') then
      s_error('string ending not found', tok);
      --debug('Premature string ending');
    end if;

    --debug(varbuf);
    --dbms_output.put_line(varbuf);
    if((v_extended IS NOT NULL AND v_extended::text <> '')) then
      updateClob(v_extended, unistr(varbuf));
      tok.data_overflow := v_extended;
      tok.data := dbms_lob.substring(v_extended from 1 for 32767);
    else
      tok.data := unistr(varbuf);
    end if;
    return indx;
  END;

$body$
LANGUAGE PLPGSQL;


  /* scanner tokens:
    '{', '}', ',', ':', '[', ']', STRING, NUMBER, TRUE, FALSE, NULL
  */


CREATE OR REPLACE FUNCTION JSON_PARSER.lexer (jsrc in out nocopy json_src)  RETURNS lTokens AS $body$
DECLARE

    tokens lTokens;
    indx integer := 1;
    tok_indx integer := 1;
    buf varchar(4);
    lin_no bigint := 1;
    col_no bigint := 0;
  
BEGIN
    while (indx <= jsrc.len) loop
      --read into buf
      buf := next_char(indx, jsrc);
      col_no := col_no + 1;
      --convert to switch case
      case
        when buf = '{' then tokens(tok_indx) := mt('{', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = '}' then tokens(tok_indx) := mt('}', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = ',' then tokens(tok_indx) := mt(',', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = ':' then tokens(tok_indx) := mt(':', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = '[' then tokens(tok_indx) := mt('[', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = ']' then tokens(tok_indx) := mt(']', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = 't' then
          if(next_char2(indx, jsrc, 4) != 'true') then
            if(json_strict = false and REGEXP_LIKE(buf, '^[[alpha:]]$', 'i')) then
              tokens(tok_indx) := mt('STRING', lin_no, col_no, null);
              indx := lexName(jsrc, tokens(tok_indx), indx);
              col_no := col_no + length(tokens(tok_indx).data) + 1;
              tok_indx := tok_indx + 1;
            else
              s_error('Expected: ''true''', lin_no, col_no);
            end if;
          else
            tokens(tok_indx) := mt('TRUE', lin_no, col_no, null); tok_indx := tok_indx + 1;
            indx := indx + 3;
            col_no := col_no + 3;
          end if;
        when buf = 'n' then
          if(next_char2(indx, jsrc, 4) != 'null') then
            if(json_strict = false and REGEXP_LIKE(buf, '^[[alpha:]]$', 'i')) then
              tokens(tok_indx) := mt('STRING', lin_no, col_no, null);
              indx := lexName(jsrc, tokens(tok_indx), indx);
              col_no := col_no + length(tokens(tok_indx).data) + 1;
              tok_indx := tok_indx + 1;
            else
              s_error('Expected: ''null''', lin_no, col_no);
            end if;
          else
            tokens(tok_indx) := mt('NULL', lin_no, col_no, null); tok_indx := tok_indx + 1;
            indx := indx + 3;
            col_no := col_no + 3;
          end if;
        when buf = 'f' then
          if(next_char2(indx, jsrc, 5) != 'false') then
            if(json_strict = false and REGEXP_LIKE(buf, '^[[alpha:]]$', 'i')) then
              tokens(tok_indx) := mt('STRING', lin_no, col_no, null);
              indx := lexName(jsrc, tokens(tok_indx), indx);
              col_no := col_no + length(tokens(tok_indx).data) + 1;
              tok_indx := tok_indx + 1;
            else
              s_error('Expected: ''false''', lin_no, col_no);
            end if;
          else
            tokens(tok_indx) := mt('FALSE', lin_no, col_no, null); tok_indx := tok_indx + 1;
            indx := indx + 4;
            col_no := col_no + 4;
          end if;
        /*   -- 9 = TAB, 10 = \n, 13 = \r (Linux = \n, Windows = \r\n, Mac = \r */
        when (buf = Chr(10)) then --linux newlines
          lin_no := lin_no + 1;
          col_no := 0;

        when (buf = Chr(13)) then --Windows or Mac way
          lin_no := lin_no + 1;
          col_no := 0;
          if(jsrc.len >= indx +1) then -- better safe than sorry
            buf := next_char(indx+1, jsrc);
            if(buf = Chr(10)) then --\r\n
              indx := indx + 1;
            end if;
          end if;

        when (buf = CHR(9)) then null; --tabbing
        when (buf in ('-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9')) then --number
          tokens(tok_indx) := mt('numeric', lin_no, col_no, null);
          indx := lexNumber(jsrc, tokens(tok_indx), indx)-1;
          col_no := col_no + length(tokens(tok_indx).data);
          tok_indx := tok_indx + 1;
        when buf = '"' then --number
          tokens(tok_indx) := mt('STRING', lin_no, col_no, null);
          indx := lexString(jsrc, tokens(tok_indx), indx, '"');
          col_no := col_no + length(tokens(tok_indx).data) + 1;
          tok_indx := tok_indx + 1;
        when buf = '''' and json_strict = false then --number
          tokens(tok_indx) := mt('STRING', lin_no, col_no, null);
          indx := lexString(jsrc, tokens(tok_indx), indx, '''');
          col_no := col_no + length(tokens(tok_indx).data) + 1; --hovsa her
          tok_indx := tok_indx + 1;
        when json_strict = false and REGEXP_LIKE(buf, '^[[alpha:]]$', 'i') then
          tokens(tok_indx) := mt('STRING', lin_no, col_no, null);
          indx := lexName(jsrc, tokens(tok_indx), indx);
          if(tokens(tok_indx)(.data_overflow IS NOT NULL AND .data_overflow::text <> '')) then
            col_no := col_no + dbms_lob.getlength(tokens(tok_indx).data_overflow) + 1;
          else
            col_no := col_no + length(tokens(tok_indx).data) + 1;
          end if;
          tok_indx := tok_indx + 1;
        when json_strict = false and buf||next_char(indx+1, jsrc) = '/*' then --strip comments
          declare
            saveindx number := indx;
            un_esc clob;
          begin
            indx := indx + 1;
            loop
              indx := indx + 1;
              buf := next_char(indx, jsrc)||next_char(indx+1, jsrc);
              exit when buf = '*/
';
              exit when coalesce(buf::text, '') = '';
            end loop;

            if(indx = saveindx+2) then
              --enter unescaped mode
              --dbms_output.put_line('Entering unescaped mode');
              un_esc := empty_clob();
              dbms_lob.createtemporary(un_esc, true);
              indx := indx + 1;
              loop
                indx := indx + 1;
                buf := next_char(indx, jsrc)||next_char(indx+1, jsrc)||next_char(indx+2, jsrc)||next_char(indx+3, jsrc);
                exit when buf = '/**/
';
                if coalesce(buf::text, '') = '' then
                  s_error('Unexpected sequence /**/
 to end unescaped data: '||buf, lin_no, col_no);
                end if;
                buf := next_char(indx, jsrc);
                dbms_lob.writeappend(un_esc, length(buf), buf);
              end loop;
              tokens(tok_indx) := mt('ESTRING', lin_no, col_no, null);
              tokens(tok_indx).data_overflow := un_esc;
              col_no := col_no + dbms_lob.getlength(un_esc) + 1; --note: line count won't work properly
              tok_indx := tok_indx + 1;
              indx := indx + 2;
            end if;

            indx := indx + 1;
          end;
        when buf = ' ' then null; --space
        else
          s_error('Unexpected char: '||buf, lin_no, col_no);
      end case;

      indx := indx + 1;
    end loop;

    return tokens;
  END;

$body$
LANGUAGE PLPGSQL;


  /* SCANNER END */

  /* PARSER FUNCTIONS START*/


CREATE OR REPLACE FUNCTION JSON_PARSER.p_error (text text, tok rToken)  RETURNS VOID AS $body$
BEGIN
    RAISE EXCEPTION 'JSON Parser exception @ line: % column: % - %',tok.line,tok.col,text;
  end;


$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PARSER.parsearr (tokens lTokens, indx in out nocopy pls_integer)  RETURNS json_list AS $body$
DECLARE

    e_arr json_value_array := json_value_array();
    ret_list json_list := json_list();
    v_count bigint := 0;
    tok rToken;
  
BEGIN
    --value, value, value ]
    if(indx > tokens.count) then p_error('more elements in array was excepted', tok); end if;
    tok := tokens(indx);
    while(tok.type_name != ']') loop
      e_arr.extend;
      v_count := v_count + 1;
      case tok.type_name
        when 'TRUE' then e_arr(v_count) := json_value(true);
        when 'FALSE' then e_arr(v_count) := json_value(false);
        when 'NULL' then e_arr(v_count) := json_value;
        when 'STRING' then e_arr(v_count) := case when (tok.data_overflow IS NOT NULL AND tok.data_overflow::text <> '') then json_value(tok.data_overflow) else json_value(tok.data) end;
        when 'ESTRING' then e_arr(v_count) := json_value(tok.data_overflow, false);
        when 'numeric' then e_arr(v_count) := json_value(to_number(replace(tok.data, '.', decimalpoint)));
        when '[' then
          declare e_list json_list; begin
            indx := indx + 1;
            e_list := parseArr(tokens, indx);
            e_arr(v_count) := e_list.to_json_value;
          end;
        when '{' then
          indx := indx + 1;
          e_arr(v_count) := parseObj(tokens, indx).to_json_value;
        else
          p_error('Expected a value', tok);
      end case;
      indx := indx + 1;
      if(indx > tokens.count) then p_error('] not found', tok); end if;
      tok := tokens(indx);
      if(tok.type_name = ',') then --advance
        indx := indx + 1;
        if(indx > tokens.count) then p_error('more elements in array was excepted', tok); end if;
        tok := tokens(indx);
        if(tok.type_name = ']') then --premature exit
          p_error('Premature exit in array', tok);
        end if;
      elsif(tok.type_name != ']') then --error
        p_error('Expected , or ]', tok);
      end if;

    end loop;
    ret_list.list_data := e_arr;
    return ret_list;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PARSER.parsemem (tokens lTokens, indx in out pls_integer, mem_name text, mem_indx bigint)  RETURNS json_value AS $body$
DECLARE

    mem json_value;
    tok rToken;
  
BEGIN
    tok := tokens(indx);
    case tok.type_name
      when 'TRUE' then mem := json_value(true);
      when 'FALSE' then mem := json_value(false);
      when 'NULL' then mem := json_value;
      when 'STRING' then mem := case when (tok.data_overflow IS NOT NULL AND tok.data_overflow::text <> '') then json_value(tok.data_overflow) else json_value(tok.data) end;
      when 'ESTRING' then mem := json_value(tok.data_overflow, false);
      when 'numeric' then mem := json_value(to_number(replace(tok.data, '.', decimalpoint)));
      when '[' then
        declare
          e_list json_list;
        begin
          indx := indx + 1;
          e_list := parseArr(tokens, indx);
          mem := e_list.to_json_value;
        end;
      when '{' then
        indx := indx + 1;
        mem := parseObj(tokens, indx).to_json_value;
      else
        p_error('Found '||tok.type_name, tok);
    end case;
    mem.mapname := mem_name;
    mem.mapindx := mem_indx;

    indx := indx + 1;
    return mem;
  END;

$body$
LANGUAGE PLPGSQL;


  /*procedure test_duplicate_members(arr in json_member_array, mem_name in varchar2, wheretok rToken) as
  begin
    for i in 1 .. arr.count loop
      if(arr(i).member_name = mem_name) then
        p_error('Duplicate member name', wheretok);
      end if;
    end loop;
  end test_duplicate_members;*/



CREATE OR REPLACE FUNCTION JSON_PARSER.parseobj (tokens lTokens, indx in out nocopy pls_integer)  RETURNS json AS $body$
DECLARE

    type memmap is table of bigint index by varchar(4000); -- i've read somewhere that this is not possible - but it is!
    mymap memmap;
    nullelemfound boolean := false;

    obj json;
    tok rToken;
    mem_name varchar(4000);
    arr json_value_array := json_value_array();
  
BEGIN
    --what to expect?
    while(indx <= tokens.count) loop
      tok := tokens(indx);
      --debug('E: '||tok.type_name);
      case tok.type_name
      when 'STRING' then
        --member
        mem_name := substring(tok.data from 1 for 4000);
        begin
          if(coalesce(mem_name::text, '') = '') then
            if(nullelemfound) then
              p_error('Duplicate empty member: ', tok);
            else
              nullelemfound := true;
            end if;
          elsif(mymap(mem_name) is not null) then
            p_error('Duplicate member name: '||mem_name, tok);
          end if;
        exception
          when no_data_found then mymap(mem_name) := 1;
        end;

        indx := indx + 1;
        if(indx > tokens.count) then p_error('Unexpected end of input', tok); end if;
        tok := tokens(indx);
        indx := indx + 1;
        if(indx > tokens.count) then p_error('Unexpected end of input', tok); end if;
        if(tok.type_name = ':') then
          --parse
          declare
            jmb json_value;
            x numeric;
          begin
            x := arr.count + 1;
            jmb := parseMem(tokens, indx, mem_name, x);
            arr.extend;
            arr(x) := jmb;
          end;
        else
          p_error('Expected '':''', tok);
        end if;
        --move indx forward if ',' is found
        if(indx > tokens.count) then p_error('Unexpected end of input', tok); end if;

        tok := tokens(indx);
        if(tok.type_name = ',') then
          --debug('found ,');
          indx := indx + 1;
          tok := tokens(indx);
          if(tok.type_name = '}') then --premature exit
            p_error('Premature exit in json object', tok);
          end if;
        elsif(tok.type_name != '}') then
           p_error('A comma seperator is probably missing', tok);
        end if;
      when '}' then
        obj := json();
        obj.json_data := arr;
        return obj;
      else
        p_error('Expected string or }', tok);
      end case;
    end loop;

    p_error('} not found', tokens(indx-1));

    return obj;

  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PARSER.parser (str text)  RETURNS json AS $body$
DECLARE

    tokens lTokens;
    obj json;
    indx integer := 1;
    jsrc json_src;
  
BEGIN
    updateDecimalPoint();
    jsrc := prepareVarchar2(str);
    tokens := lexer(jsrc);
    if(tokens(indx).type_name = '{') then
      indx := indx + 1;
      obj := parseObj(tokens, indx);
    else
      RAISE EXCEPTION 'JSON Parser exception - no { start found';
    end if;
    if(tokens.count != indx) then
      p_error('} should end the JSON object', tokens(indx));
    end if;

    return obj;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PARSER.parse_list (str text)  RETURNS json_list AS $body$
DECLARE

    tokens lTokens;
    obj json_list;
    indx integer := 1;
    jsrc json_src;
  
BEGIN
    updateDecimalPoint();
    jsrc := prepareVarchar2(str);
    tokens := lexer(jsrc);
    if(tokens(indx).type_name = '[') then
      indx := indx + 1;
      obj := parseArr(tokens, indx);
    else
      RAISE EXCEPTION 'JSON List Parser exception - no [ start found';
    end if;
    if(tokens.count != indx) then
      p_error('] should end the JSON List object', tokens(indx));
    end if;

    return obj;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PARSER.parse_list (str text)  RETURNS json_list AS $body$
DECLARE

    tokens lTokens;
    obj json_list;
    indx integer := 1;
    jsrc json_src;
  
BEGIN
    updateDecimalPoint();
    jsrc := prepareClob(str);
    tokens := lexer(jsrc);
    if(tokens(indx).type_name = '[') then
      indx := indx + 1;
      obj := parseArr(tokens, indx);
    else
      RAISE EXCEPTION 'JSON List Parser exception - no [ start found';
    end if;
    if(tokens.count != indx) then
      p_error('] should end the JSON List object', tokens(indx));
    end if;

    return obj;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PARSER.parser (str text)  RETURNS json AS $body$
DECLARE

    tokens lTokens;
    obj json;
    indx integer := 1;
    jsrc json_src;
  
BEGIN
    updateDecimalPoint();
    --dbms_output.put_line('Using clob');
    jsrc := prepareClob(str);
    tokens := lexer(jsrc);
    if(tokens(indx).type_name = '{') then
      indx := indx + 1;
      obj := parseObj(tokens, indx);
    else
      RAISE EXCEPTION 'JSON Parser exception - no { start found';
    end if;
    if(tokens.count != indx) then
      p_error('} should end the JSON object', tokens(indx));
    end if;

    return obj;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PARSER.parse_any (str text)  RETURNS json_value AS $body$
DECLARE

    tokens lTokens;
    obj json_list;
    ret json_value;
    indx integer := 1;
    jsrc json_src;
  
BEGIN
    updateDecimalPoint();
    jsrc := prepareVarchar2(str);
    tokens := lexer(jsrc);
    tokens(tokens.count+1).type_name := ']';
    obj := parseArr(tokens, indx);
    if(tokens.count != indx) then
      p_error('] should end the JSON List object', tokens(indx));
    end if;

    return obj.head();
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PARSER.parse_any (str text)  RETURNS json_value AS $body$
DECLARE

    tokens lTokens;
    obj json_list;
    indx integer := 1;
    jsrc json_src;
  
BEGIN
    jsrc := prepareClob(str);
    tokens := lexer(jsrc);
    tokens(tokens.count+1).type_name := ']';
    obj := parseArr(tokens, indx);
    if(tokens.count != indx) then
      p_error('] should end the JSON List object', tokens(indx));
    end if;

    return obj.head();
  END;

$body$
LANGUAGE PLPGSQL;


  /* last entry is the one to keep */


CREATE OR REPLACE FUNCTION JSON_PARSER.remove_duplicates (obj in out nocopy json)  RETURNS nocopy AS $body$
DECLARE

    type memberlist is table of json_value index by varchar(4000);
    members memberlist;
    nulljsonvalue json_value := null;
    validated json := json();
    indx varchar(4000);
  
BEGIN
    for i in 1 .. obj.count loop
      if(obj.get(i)coalesce(.mapname::text, '') = '') then
        nulljsonvalue := obj.get(i);
      else
        members(obj.get(i).mapname) := obj.get(i);
      end if;
    end loop;

    validated.check_duplicate(false);
    indx := members.first;
    loop
      exit when coalesce(indx::text, '') = '';
      validated.put(indx, members(indx));
      indx := members.next(indx);
    end loop;
    if((nulljsonvalue IS NOT NULL AND nulljsonvalue::text <> '')) then
      validated.put('', nulljsonvalue);
    end if;

    validated.check_for_duplicate := obj.check_for_duplicate;

    obj := validated;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PARSER.get_version () RETURNS varchar AS $body$
BEGIN
    return 'PL/JSON v1.0.4';
  END;

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'JSON_PARSER' declaration

-- Oracle package 'JSON_PRINTER' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS JSON_PRINTER CASCADE;
CREATE SCHEMA JSON_PRINTER;

max_line_len number := 0;
  cur_line_len number := 0;



CREATE OR REPLACE FUNCTION JSON_PRINTER.llcheck (str in text)  RETURNS varchar AS $body$
BEGIN
    --dbms_output.put_line(cur_line_len || ' : '|| str);
    if(max_line_len > 0 and length(str)+cur_line_len > max_line_len) then
      cur_line_len := length(str);
      return newline_char || str;
    else
      cur_line_len := cur_line_len + length(str);
      return str;
    end if;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PRINTER.escapestring (str text)  RETURNS varchar AS $body$
DECLARE

    sb varchar(32767) := '';
    buf varchar(40);
    num bigint;
  
BEGIN
    if(coalesce(str::text, '') = '') then return ''; end if;
    for i in 1 .. length(str) loop
      buf := substring(str from i for 1);
      --backspace b = U+0008
      --formfeed  f = U+000C
      --newline   n = U+000A
      --carret    r = U+000D
      --tabulator t = U+0009
      case buf
      when chr( 8) then buf := '\b';
      when chr( 9) then buf := '\t';
      when chr(10) then buf := '\n';
      when chr(13) then buf := '\f';
      when chr(14) then buf := '\r';
      when chr(34) then buf := '\"';
      when chr(47) then if(escape_solidus) then buf := '\/'; end if;
      when chr(92) then buf := '\\';
      else
        if(ascii(buf) < 32) then
          buf := '\u'||replace(substr(to_char(ascii(buf), 'XXXX'),2,4), ' ', '0');
        elsif (ascii_output) then
          buf := replace(asciistr(buf), '\', '\u');
        end if;
      end case;

      sb := sb || buf;
    end loop;

    return sb;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PRINTER.newline (spaces boolean)  RETURNS varchar AS $body$
BEGIN
    cur_line_len := 0;
    if(spaces) then return newline_char; else return ''; end if;
  end;

/*  function get_schema return varchar2 as
  begin
    return sys_context('userenv', 'current_schema');
  end;
*/

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PRINTER.tab (indent bigint, spaces boolean)  RETURNS varchar AS $body$
DECLARE

    i varchar(200) := '';
  
BEGIN
    if(not spaces) then return ''; end if;
    for x in 1 .. indent loop i := i || indent_string; end loop;
    return i;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PRINTER.getcommasep (spaces boolean)  RETURNS varchar AS $body$
BEGIN
    if(spaces) then return ', '; else return ','; end if;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PRINTER.getmemname (mem json_value, spaces boolean)  RETURNS varchar AS $body$
BEGIN
    if(spaces) then
      return llcheck('"'||escapeString(mem.mapname)||'"') || llcheck(' : ');
    else
      return llcheck('"'||escapeString(mem.mapname)||'"') || llcheck(':');
    end if;
  end;

/* Clob method start here */

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PRINTER.add_to_clob (buf_lob in out nocopy text, buf_str in out nocopy text, str text)  RETURNS RECORD AS $body$
BEGIN
    if(lengthb(str) > 32767 - lengthb(buf_str)) then
--      dbms_lob.append(buf_lob, buf_str);
      dbms_lob.writeappend(buf_lob, length(buf_str), buf_str);
      buf_str := str;
    else
      buf_str := buf_str || str;
    end if;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PRINTER.flush_clob (buf_lob in out nocopy text, buf_str in out nocopy text)  RETURNS RECORD AS $body$
BEGIN
--    dbms_lob.append(buf_lob, buf_str);
    dbms_lob.writeappend(buf_lob, length(buf_str), buf_str);
  END;

$body$
LANGUAGE PLPGSQL;
;



CREATE OR REPLACE FUNCTION JSON_PRINTER.ppea (input json_list, indent bigint, buf in out nocopy text, spaces boolean, buf_str in out nocopy text)  RETURNS RECORD AS $body$
DECLARE

    elem json_value;
    arr json_value_array := input.list_data;
    numbuf varchar(4000);
  
BEGIN
    for y in 1 .. arr.count loop
      elem := arr(y);
      if((elem IS NOT NULL AND elem::text <> '')) then
      case elem.get_type
        when 'numeric' then
          numbuf := '';
          if (elem.get_number < 1 and elem.get_number > 0) then numbuf := '0'; end if;
          if (elem.get_number < 0 and elem.get_number > -1) then
            numbuf := '-0';
            numbuf := numbuf || substr(to_char(elem.get_number, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,'''),2);
          else
            numbuf := numbuf || to_char(elem.get_number, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,''');
          end if;
          add_to_clob(buf, buf_str, llcheck(numbuf));
        when 'string' then
          if((elem.extended_str IS NOT NULL AND elem.extended_str::text <> '')) then --clob implementation
            add_to_clob(buf, buf_str, case when elem.num = 1 then '"' else '/**/
' end);
            declare
              offset numeric := 1;
              v_str varchar(32767);
              amount numeric := 32767;
            begin
              while(offset <= dbms_lob.getlength(elem.extended_str)) loop
                dbms_lob.read(elem.extended_str, amount, offset, v_str);
                if(elem.num = 1) then
                  add_to_clob(buf, buf_str, escapeString(v_str));
                else
                  add_to_clob(buf, buf_str, v_str);
                end if;
                offset := offset + amount;
              end loop;
            end;
            add_to_clob(buf, buf_str, case when elem.num = 1 then '"' else '/**/
' end || newline_char);
          else
            if(elem.num = 1) then
              add_to_clob(buf, buf_str, llcheck('"'||escapeString(elem.get_string)||'"'));
            else
              add_to_clob(buf, buf_str, llcheck('/**/
'||elem.get_string||'/**/
'));
            end if;
          end if;
        when 'bool' then
          if(elem.get_bool) then
            add_to_clob(buf, buf_str, llcheck('true'));
          else
            add_to_clob(buf, buf_str, llcheck('false'));
          end if;
        when 'null' then
          add_to_clob(buf, buf_str, llcheck('null'));
        when 'array' then
          add_to_clob(buf, buf_str, llcheck('['));
          ppEA(json_list(elem), indent, buf, spaces, buf_str);
          add_to_clob(buf, buf_str, llcheck(']'));
        when 'object' then
          ppObj(json(elem), indent, buf, spaces, buf_str);
        else add_to_clob(buf, buf_str, llcheck(elem.get_type));
      end case;
      end if;
      if(y != arr.count) then add_to_clob(buf, buf_str, llcheck(getCommaSep(spaces))); end if;
    end loop;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PRINTER.ppmem (mem json_value, indent bigint, buf in out nocopy text, spaces boolean, buf_str in out nocopy text)  RETURNS RECORD AS $body$
DECLARE

    numbuf varchar(4000);
  
BEGIN
    add_to_clob(buf, buf_str, llcheck(tab(indent, spaces)) || llcheck(getMemName(mem, spaces)));
    case mem.get_type
      when 'numeric' then
        if (mem.get_number < 1 and mem.get_number > 0) then numbuf := '0'; end if;
        if (mem.get_number < 0 and mem.get_number > -1) then
          numbuf := '-0';
          numbuf := numbuf || substr(to_char(mem.get_number, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,'''),2);
        else
          numbuf := numbuf || to_char(mem.get_number, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,''');
        end if;
        add_to_clob(buf, buf_str, llcheck(numbuf));
      when 'string' then
        if((mem.extended_str IS NOT NULL AND mem.extended_str::text <> '')) then --clob implementation
          add_to_clob(buf, buf_str, case when mem.num = 1 then '"' else '/**/
' end);
          declare
            offset numeric := 1;
            v_str varchar(32767);
            amount numeric := 32767;
          begin
--            dbms_output.put_line('SIZE:'||dbms_lob.getlength(mem.extended_str));
            while(offset <= dbms_lob.getlength(mem.extended_str)) loop
--            dbms_output.put_line('OFFSET:'||offset);
 --             v_str := dbms_lob.substr(mem.extended_str, 8192, offset);
              dbms_lob.read(mem.extended_str, amount, offset, v_str);
--            dbms_output.put_line('VSTR_SIZE:'||length(v_str));
              if(mem.num = 1) then
                add_to_clob(buf, buf_str, escapeString(v_str));
              else
                add_to_clob(buf, buf_str, v_str);
              end if;
              offset := offset + amount;
            end loop;
          end;
          add_to_clob(buf, buf_str, case when mem.num = 1 then '"' else '/**/
' end || newline_char);
        else
          if(mem.num = 1) then
            add_to_clob(buf, buf_str, llcheck('"'||escapeString(mem.get_string)||'"'));
          else
            add_to_clob(buf, buf_str, llcheck('/**/
'||mem.get_string||'/**/
'));
          end if;
        end if;
      when 'bool' then
        if(mem.get_bool) then
          add_to_clob(buf, buf_str, llcheck('true'));
        else
          add_to_clob(buf, buf_str, llcheck('false'));
        end if;
      when 'null' then
        add_to_clob(buf, buf_str, llcheck('null'));
      when 'array' then
        add_to_clob(buf, buf_str, llcheck('['));
        ppEA(json_list(mem), indent, buf, spaces, buf_str);
        add_to_clob(buf, buf_str, llcheck(']'));
      when 'object' then
        ppObj(json(mem), indent, buf, spaces, buf_str);
      else add_to_clob(buf, buf_str, llcheck(mem.get_type));
    end case;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PRINTER.ppobj (obj json, indent bigint, buf in out nocopy text, spaces boolean, buf_str in out nocopy text)  RETURNS RECORD AS $body$
BEGIN
    add_to_clob(buf, buf_str, llcheck('{') || newline(spaces));
    for m in 1 .. obj.json_data.count loop
      ppMem(obj.json_data(m), indent+1, buf, spaces, buf_str);
      if(m != obj.json_data.count) then
        add_to_clob(buf, buf_str, llcheck(',') || newline(spaces));
      else
        add_to_clob(buf, buf_str, newline(spaces));
      end if;
    end loop;
    add_to_clob(buf, buf_str, llcheck(tab(indent, spaces)) || llcheck('}')); -- || chr(13);
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PRINTER.pretty_print (obj json, spaces boolean default true, buf in out nocopy text, line_length bigint default 0, erase_clob boolean default true)  RETURNS nocopy AS $body$
DECLARE

    buf_str varchar(32767);
    amount bigint := dbms_lob.getlength(buf);
  
BEGIN
    if(erase_clob and amount > 0) then dbms_lob.trim(buf, 0); dbms_lob.erase(buf, amount); end if;

    max_line_len := line_length;
    cur_line_len := 0;
    ppObj(obj, 0, buf, spaces, buf_str);
    flush_clob(buf, buf_str);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PRINTER.pretty_print_list (obj json_list, spaces boolean default true, buf in out nocopy text, line_length bigint default 0, erase_clob boolean default true)  RETURNS nocopy AS $body$
DECLARE

    buf_str varchar(32767);
    amount bigint := dbms_lob.getlength(buf);
  
BEGIN
    if(erase_clob and amount > 0) then dbms_lob.trim(buf, 0); dbms_lob.erase(buf, amount); end if;

    max_line_len := line_length;
    cur_line_len := 0;
    add_to_clob(buf, buf_str, llcheck('['));
    ppEA(obj, 0, buf, spaces, buf_str);
    add_to_clob(buf, buf_str, llcheck(']'));
    flush_clob(buf, buf_str);
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PRINTER.pretty_print_any (json_part json_value, spaces boolean default true, buf in out nocopy text, line_length bigint default 0, erase_clob boolean default true)  RETURNS nocopy AS $body$
DECLARE

    buf_str varchar(32767) := '';
    numbuf varchar(4000);
    amount bigint := dbms_lob.getlength(buf);
  
BEGIN
    if(erase_clob and amount > 0) then dbms_lob.trim(buf, 0); dbms_lob.erase(buf, amount); end if;

    case json_part.get_type
      when 'numeric' then
        if (json_part.get_number < 1 and json_part.get_number > 0) then numbuf := '0'; end if;
        if (json_part.get_number < 0 and json_part.get_number > -1) then
          numbuf := '-0';
          numbuf := numbuf || substr(to_char(json_part.get_number, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,'''),2);
        else
          numbuf := numbuf || to_char(json_part.get_number, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,''');
        end if;
        add_to_clob(buf, buf_str, numbuf);
      when 'string' then
        if((json_part.extended_str IS NOT NULL AND json_part.extended_str::text <> '')) then --clob implementation
          add_to_clob(buf, buf_str, case when json_part.num = 1 then '"' else '/**/
' end);
          declare
            offset numeric := 1;
            v_str varchar(32767);
            amount numeric := 32767;
          begin
            while(offset <= dbms_lob.getlength(json_part.extended_str)) loop
              dbms_lob.read(json_part.extended_str, amount, offset, v_str);
              if(json_part.num = 1) then
                add_to_clob(buf, buf_str, escapeString(v_str));
              else
                add_to_clob(buf, buf_str, v_str);
              end if;
              offset := offset + amount;
            end loop;
          end;
          add_to_clob(buf, buf_str, case when json_part.num = 1 then '"' else '/**/
' end);
        else
          if(json_part.num = 1) then
            add_to_clob(buf, buf_str, llcheck('"'||escapeString(json_part.get_string)||'"'));
          else
            add_to_clob(buf, buf_str, llcheck('/**/
'||json_part.get_string||'/**/
'));
          end if;
        end if;
      when 'bool' then
	      if(json_part.get_bool) then
          add_to_clob(buf, buf_str, 'true');
        else
          add_to_clob(buf, buf_str, 'false');
        end if;
      when 'null' then
        add_to_clob(buf, buf_str, 'null');
      when 'array' then
        pretty_print_list(json_list(json_part), spaces, buf, line_length);
        return;
      when 'object' then
        pretty_print(json(json_part), spaces, buf, line_length);
        return;
      else add_to_clob(buf, buf_str, 'unknown type:'|| json_part.get_type);
    end case;
    flush_clob(buf, buf_str);
  end;

/* Clob method end here */

/* Varchar2 method start here */


$body$
LANGUAGE PLPGSQL;
;



CREATE OR REPLACE FUNCTION JSON_PRINTER.ppea (input json_list, indent bigint, buf in out text, spaces boolean)  RETURNS text AS $body$
DECLARE

    elem json_value;
    arr json_value_array := input.list_data;
    str varchar(400);
  
BEGIN
    for y in 1 .. arr.count loop
      elem := arr(y);
      if((elem IS NOT NULL AND elem::text <> '')) then
      case elem.get_type
        when 'numeric' then
          str := '';
          if (elem.get_number < 1 and elem.get_number > 0) then str := '0'; end if;
          if (elem.get_number < 0 and elem.get_number > -1) then
            str := '-0' || substr(to_char(elem.get_number, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,'''),2);
          else
            str := str || to_char(elem.get_number, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,''');
          end if;
          buf := buf || llcheck(str);
        when 'string' then
          if(elem.num = 1) then
            buf := buf || llcheck('"'||escapeString(elem.get_string)||'"');
          else
            buf := buf || llcheck('/**/
'||elem.get_string||'/**/
');
          end if;
        when 'bool' then
          if(elem.get_bool) then
            buf := buf || llcheck('true');
          else
            buf := buf || llcheck('false');
          end if;
        when 'null' then
          buf := buf || llcheck('null');
        when 'array' then
          buf := buf || llcheck('[');
          ppEA(json_list(elem), indent, buf, spaces);
          buf := buf || llcheck(']');
        when 'object' then
          ppObj(json(elem), indent, buf, spaces);
        else buf := buf || llcheck(elem.get_type); /* should never happen */
      end case;
      end if;
      if(y != arr.count) then buf := buf || llcheck(getCommaSep(spaces)); end if;
    end loop;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PRINTER.ppmem (mem json_value, indent bigint, buf in out nocopy text, spaces boolean)  RETURNS nocopy AS $body$
DECLARE

    str varchar(400) := '';
  
BEGIN
    buf := buf || llcheck(tab(indent, spaces)) || getMemName(mem, spaces);
    case mem.get_type
      when 'numeric' then
        if (mem.get_number < 1 and mem.get_number > 0) then str := '0'; end if;
        if (mem.get_number < 0 and mem.get_number > -1) then
          str := '-0' || substr(to_char(mem.get_number, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,'''),2);
        else
          str := str || to_char(mem.get_number, 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,''');
        end if;
        buf := buf || llcheck(str);
      when 'string' then
        if(mem.num = 1) then
          buf := buf || llcheck('"'||escapeString(mem.get_string)||'"');
        else
          buf := buf || llcheck('/**/
'||mem.get_string||'/**/
');
        end if;
      when 'bool' then
        if(mem.get_bool) then
          buf := buf || llcheck('true');
        else
          buf := buf || llcheck('false');
        end if;
      when 'null' then
        buf := buf || llcheck('null');
      when 'array' then
        buf := buf || llcheck('[');
        ppEA(json_list(mem), indent, buf, spaces);
        buf := buf || llcheck(']');
      when 'object' then
        ppObj(json(mem), indent, buf, spaces);
      else buf := buf || llcheck(mem.get_type); /* should never happen */
    end case;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PRINTER.ppobj (obj json, indent bigint, buf in out nocopy text, spaces boolean)  RETURNS nocopy AS $body$
BEGIN
    buf := buf || llcheck('{') || newline(spaces);
    for m in 1 .. obj.json_data.count loop
      ppMem(obj.json_data(m), indent+1, buf, spaces);
      if(m != obj.json_data.count) then buf := buf || llcheck(',') || newline(spaces);
      else buf := buf || newline(spaces); end if;
    end loop;
    buf := buf || llcheck(tab(indent, spaces)) || llcheck('}'); -- || chr(13);
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PRINTER.pretty_print (obj json, spaces boolean default true, line_length bigint default 0)  RETURNS varchar AS $body$
DECLARE

    buf varchar(32767) := '';
  
BEGIN
    max_line_len := line_length;
    cur_line_len := 0;
    ppObj(obj, 0, buf, spaces);
    return buf;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION JSON_PRINTER.pretty_print_list (obj json_list, spaces boolean default true, line_length bigint default 0)  RETURNS varchar AS $body$
DECLARE

    buf varchar(32767);
  
BEGIN
    max_line_len := line_length;
    cur_line_len := 0;
    buf := llcheck('[');
    ppEA(obj, 0, buf, spaces);
    buf := buf || llcheck(']');
    return buf;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PRINTER.pretty_print_any (json_part json_value, spaces boolean default true, line_length bigint default 0)  RETURNS varchar AS $body$
DECLARE

    buf varchar(32767) := '';
  
BEGIN
    case json_part.get_type
      when 'numeric' then
        if (json_part.get_number() < 1 and json_part.get_number() > 0) then buf := buf || '0'; end if;
        if (json_part.get_number() < 0 and json_part.get_number() > -1) then
          buf := buf || '-0';
          buf := buf || substr(to_char(json_part.get_number(), 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,'''),2);
        else
          buf := buf || to_char(json_part.get_number(), 'TM9', 'NLS_NUMERIC_CHARACTERS=''.,''');
        end if;
      when 'string' then
        if(json_part.num = 1) then
          buf := buf || '"'||escapeString(json_part.get_string)||'"';
        else
          buf := buf || '/**/
'||json_part.get_string||'/**/
';
        end if;
      when 'bool' then
      	if(json_part.get_bool) then buf := 'true'; else buf := 'false'; end if;
      when 'null' then
        buf := 'null';
      when 'array' then
        buf := pretty_print_list(json_list(json_part), spaces, line_length);
      when 'object' then
        buf := pretty_print(json(json_part), spaces, line_length);
      else buf := 'weird error: '|| json_part.get_type;
    end case;
    return buf;
  end;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PRINTER.dbms_output_clob (my_clob text, delim text, jsonp text default null)  RETURNS VOID AS $body$
DECLARE

    prev bigint := 1;
    indx bigint := 1;
    size_of_nl bigint := lengthb(delim);
    v_str varchar(32767);
    amount bigint := 32767;
  
BEGIN
    if((jsonp IS NOT NULL AND jsonp::text <> '')) then RAISE NOTICE '%(', jsonp; end if;
    while(indx != 0) loop
      --read every line
      indx := dbms_lob.instr(my_clob, delim, prev+1);
 --     dbms_output.put_line(prev || ' to ' || indx);

      if(indx = 0) then
        --emit from prev to end;
        amount := 32767;
 --       dbms_output.put_line(' mycloblen ' || dbms_lob.getlength(my_clob));
        loop
          dbms_lob.read(my_clob, amount, prev, v_str);
          RAISE NOTICE '%', v_str;
          prev := prev+amount-1;
          exit when prev >= dbms_lob.getlength(my_clob);
        end loop;
      else
        amount := indx - prev;
        if(amount > 32767) then
          amount := 32767;
--          dbms_output.put_line(' mycloblen ' || dbms_lob.getlength(my_clob));
          loop
            dbms_lob.read(my_clob, amount, prev, v_str);
            RAISE NOTICE '%', v_str;
            prev := prev+amount-1;
            amount := indx - prev;
            exit when prev >= indx - 1;
            if(amount > 32767) then amount := 32767; end if;
          end loop;
          prev := indx + size_of_nl;
        else
          dbms_lob.read(my_clob, amount, prev, v_str);
          RAISE NOTICE '%', v_str;
          prev := indx + size_of_nl;
        end if;
      end if;

    end loop;
    if((jsonp IS NOT NULL AND jsonp::text <> '')) then RAISE NOTICE ')'; end if;

/*    while (amount != 0) loop
      indx := dbms_lob.instr(my_clob, delim, prev+1);

--      dbms_output.put_line(prev || ' to ' || indx);
      if(indx = 0) then
        indx := dbms_lob.getlength(my_clob)+1;
      end if;

      if(indx-prev > 32767) then
        indx := prev+32767;
      end if;
--      dbms_output.put_line(prev || ' to ' || indx);
      --substr doesnt work properly on all platforms! (come on oracle - error on Oracle VM for virtualbox)
--        dbms_output.put_line(dbms_lob.substr(my_clob, indx-prev, prev));
      amount := indx-prev;
--        dbms_output.put_line('amount'||amount);
      dbms_lob.read(my_clob, amount, prev, v_str);
      dbms_output.put_line(v_str);
      prev := indx+size_of_nl;
      if(amount = 32767) then prev := prev-size_of_nl-1; end if;
    end loop;
    if(jsonp is not null) then dbms_output.put_line(')'); end if;*/
  end;


/*  procedure dbms_output_clob(my_clob clob, delim varchar2, jsonp varchar2 default null) as
    prev number := 1;
    indx number := 1;
    size_of_nl number := lengthb(delim);
    v_str varchar2(32767);
    amount number;
  begin
    if(jsonp is not null) then dbms_output.put_line(jsonp||'('); end if;
    while (indx != 0) loop
      indx := dbms_lob.instr(my_clob, delim, prev+1);

--      dbms_output.put_line(prev || ' to ' || indx);
      if(indx-prev > 32767) then
        indx := prev+32767;
      end if;
--      dbms_output.put_line(prev || ' to ' || indx);
      --substr doesnt work properly on all platforms! (come on oracle - error on Oracle VM for virtualbox)
      if(indx = 0) then
--        dbms_output.put_line(dbms_lob.substr(my_clob, dbms_lob.getlength(my_clob)-prev+size_of_nl, prev));
        amount := dbms_lob.getlength(my_clob)-prev+size_of_nl;
        dbms_lob.read(my_clob, amount, prev, v_str);
      else
--        dbms_output.put_line(dbms_lob.substr(my_clob, indx-prev, prev));
        amount := indx-prev;
--        dbms_output.put_line('amount'||amount);
        dbms_lob.read(my_clob, amount, prev, v_str);
      end if;
      dbms_output.put_line(v_str);
      prev := indx+size_of_nl;
      if(amount = 32767) then prev := prev-size_of_nl-1; end if;
    end loop;
    if(jsonp is not null) then dbms_output.put_line(')'); end if;
  end;
*/

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION JSON_PRINTER.htp_output_clob (my_clob text, jsonp text default null)  RETURNS VOID AS $body$
DECLARE

    /*amount number := 4096;
    pos number := 1;
    len number;
    */
    l_amt    bigint default 30;
    l_off   bigint default 1;
    l_str   varchar(4096);

  
BEGIN
    if((jsonp IS NOT NULL AND jsonp::text <> '')) then htp.prn(jsonp||'('); end if;

    begin
      loop
        dbms_lob.read( my_clob, l_amt, l_off, l_str );

        -- it is vital to use htp.PRN to avoid
        -- spurious line feeds getting added to your
        -- document
        htp.prn( l_str  );
        l_off := l_off+l_amt;
        l_amt := 4096;
      end loop;
    exception
      when no_data_found then NULL;
    end;

    /*
    len := dbms_lob.getlength(my_clob);

    while(pos < len) loop
      htp.prn(dbms_lob.substr(my_clob, amount, pos)); -- should I replace substr with dbms_lob.read?
      --dbms_output.put_line(dbms_lob.substr(my_clob, amount, pos));
      pos := pos + amount;
    end loop;
    */
    if((jsonp IS NOT NULL AND jsonp::text <> '')) then htp.prn(')'); end if;
  end;

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'JSON_PRINTER' declaration

-- Oracle package 'JSON_UTIL_PKG' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS json_util_pkg CASCADE;
CREATE SCHEMA json_util_pkg;

scanner_exception exception;
  pragma exception_init(scanner_exception, -20100);
  parser_exception exception;
  pragma exception_init(parser_exception, -20101);

  /*

  Purpose:    JSON utilities for PL/SQL

  Remarks:

  Who     Date        Description
  ------  ----------  -------------------------------------
  MBR     30.01.2010  Created

  */


  g_json_null_object             constant varchar2(20) := '{ }';




CREATE OR REPLACE FUNCTION json_util_pkg.get_xml_to_json_stylesheet () RETURNS varchar AS $body$
BEGIN

  /*

  Purpose:    return XSLT stylesheet for XML to JSON transformation

  Remarks:    see http://code.google.com/p/xml2json-xslt/

  Who     Date        Description
  ------  ----------  -------------------------------------
  MBR     30.01.2010  Created
  MBR     30.01.2010  Added fix for nulls

  */


  return q'^<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<!--
  Copyright (c) 2006,2008 Doeke Zanstra
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

  Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer. Redistributions in binary
  form must reproduce the above copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other materials provided with
  the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  THE POSSIBILITY OF SUCH DAMAGE.
-->

  <xsl:output indent="no" omit-xml-declaration="yes" method="text" encoding="UTF-8" media-type="text/x-json"/>
        <xsl:strip-space elements="*"/>
  <!--contant-->
  <xsl:variable name="d">0123456789</xsl:variable>

  <!-- ignore document text -->
  <xsl:template match="text()[preceding-sibling:node() or following-sibling:node()]"/>

  <!-- string -->
  <xsl:template match="text()">
    <xsl:call-template name="escape-string">
      <xsl:with-param name="s" select="."/>
    </xsl:call-template>
  </xsl:template>

  <!-- Main template for escaping strings; used by above template and for object-properties
       Responsibilities: placed quotes around string, and chain up to next filter, escape-bs-string -->
  <xsl:template name="escape-string">
    <xsl:param name="s"/>
    <xsl:text>"</xsl:text>
    <xsl:call-template name="escape-bs-string">
      <xsl:with-param name="s" select="$s"/>
    </xsl:call-template>
    <xsl:text>"</xsl:text>
  </xsl:template>

  <!-- Escape the backslash (\) before everything else. -->
  <xsl:template name="escape-bs-string">
    <xsl:param name="s"/>
    <xsl:choose>
      <xsl:when test="contains($s,'\')">
        <xsl:call-template name="escape-quot-string">
          <xsl:with-param name="s" select="concat(substring-before($s,'\'),'\\')"/>
        </xsl:call-template>
        <xsl:call-template name="escape-bs-string">
          <xsl:with-param name="s" select="substring-after($s,'\')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="escape-quot-string">
          <xsl:with-param name="s" select="$s"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Escape the double quote ("). -->
  <xsl:template name="escape-quot-string">
    <xsl:param name="s"/>
    <xsl:choose>
      <xsl:when test="contains($s,'&quot;')">
        <xsl:call-template name="encode-string">
          <xsl:with-param name="s" select="concat(substring-before($s,'&quot;'),'\&quot;')"/>
        </xsl:call-template>
        <xsl:call-template name="escape-quot-string">
          <xsl:with-param name="s" select="substring-after($s,'&quot;')"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:call-template name="encode-string">
          <xsl:with-param name="s" select="$s"/>
        </xsl:call-template>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- Replace tab, line feed and/or carriage return by its matching escape code. Can't escape backslash
       or double quote here, because they don't replace characters (&#x0; becomes \t), but they prefix
       characters (\ becomes \\). Besides, backslash should be seperate anyway, because it should be
       processed first. This function can't do that. -->
  <xsl:template name="encode-string">
    <xsl:param name="s"/>
    <xsl:choose>
      <!-- tab -->
      <xsl:when test="contains($s,'&#x9;')">
        <xsl:call-template name="encode-string">
          <xsl:with-param name="s" select="concat(substring-before($s,'&#x9;'),'\t',substring-after($s,'&#x9;'))"/>
        </xsl:call-template>
      </xsl:when>
      <!-- line feed -->
      <xsl:when test="contains($s,'&#xA;')">
        <xsl:call-template name="encode-string">
          <xsl:with-param name="s" select="concat(substring-before($s,'&#xA;'),'\n',substring-after($s,'&#xA;'))"/>
        </xsl:call-template>
      </xsl:when>
      <!-- carriage return -->
      <xsl:when test="contains($s,'&#xD;')">
        <xsl:call-template name="encode-string">
          <xsl:with-param name="s" select="concat(substring-before($s,'&#xD;'),'\r',substring-after($s,'&#xD;'))"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise><xsl:value-of select="$s"/></xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <!-- number (no support for javascript mantissa) -->
  <xsl:template match="text()[not(string(numeric())='NaN' or
                      (starts-with(.,'0' ) and . != '0' and
not(starts-with(.,'0.' ))) or
                      (starts-with(.,'-0' ) and . != '-0' and
not(starts-with(.,'-0.' )))
                      )]">
    <xsl:value-of select="."/>
  </xsl:template>

  <!-- boolean, case-insensitive -->
  <xsl:template match="text()[translate(.,'TRUE','true')='true']">true</xsl:template>
  <xsl:template match="text()[translate(.,'FALSE','false')='false']">false</xsl:template>

  <!-- object -->
  <xsl:template match="*" name="base">
    <xsl:if test="not(preceding-sibling::*)">{</xsl:if>
    <xsl:call-template name="escape-string">
      <xsl:with-param name="s" select="name()"/>
    </xsl:call-template>
    <xsl:text>:</xsl:text>
    <!-- check type of node -->
    <xsl:choose>
      <!-- null nodes -->
      <xsl:when test="count(child:node())=0">null</xsl:when>
      <!-- other nodes -->
      <xsl:otherwise>
        <xsl:apply-templates select="child:node()"/>
      </xsl:otherwise>
    </xsl:choose>
    <!-- end of type check -->
    <xsl:if test="following-sibling::*">,</xsl:if>
    <xsl:if test="not(following-sibling::*)">}</xsl:if>
  </xsl:template>

  <!-- array -->
  <xsl:template match="*[count(../*[name(../*)=name(.)])=count(../*) and count(../*)&gt;1]">
    <xsl:if test="not(preceding-sibling::*)">[</xsl:if>
    <xsl:choose>
      <xsl:when test="not(child::node())">
        <xsl:text>null</xsl:text>
      </xsl:when>
      <xsl:otherwise>
        <xsl:apply-templates select="child::node()"/>
      </xsl:otherwise>
    </xsl:choose>
    <xsl:if test="following-sibling::*">,</xsl:if>
    <xsl:if test="not(following-sibling::*)">]</xsl:if>
  </xsl:template>

  <!-- convert root element to an anonymous container -->
  <xsl:template match="/">
    <xsl:apply-templates select="node()"/>
  </xsl:template>

</xsl:stylesheet>^';

end get_xml_to_json_stylesheet;


function ref_cursor_to_json (p_ref_cursor in sys_refcursor,
                             p_max_rows in number := null,
                             p_skip_rows in number := null) return json_list
as
  l_ctx         dbms_xmlgen.ctxhandle;
  l_num_rows    pls_integer;
  l_xml         xmltype;
  l_json        xmltype;
  l_returnvalue clob;
begin

  /*

  Purpose:    generate JSON from REF Cursor

  Remarks:

  Who     Date        Description
  ------  ----------  -------------------------------------
  MBR     30.01.2010  Created
  JKR     01.05.2010  Edited to fit in PL/JSON

  */

  l_ctx := dbms_xmlgen.newcontext (p_ref_cursor);

  dbms_xmlgen.setnullhandling (l_ctx, dbms_xmlgen.empty_tag);

  -- for pagination

  if (p_max_rows IS NOT NULL AND p_max_rows::text <> '') then
    dbms_xmlgen.setmaxrows (l_ctx, p_max_rows);
  end if;

  if (p_skip_rows IS NOT NULL AND p_skip_rows::text <> '') then
    dbms_xmlgen.setskiprows (l_ctx, p_skip_rows);
  end if;

  -- get the XML content
  l_xml := dbms_xmlgen.getxmltype (l_ctx, dbms_xmlgen.none);

  l_num_rows := dbms_xmlgen.getnumrowsprocessed (l_ctx);

  dbms_xmlgen.closecontext (l_ctx);

  close p_ref_cursor;

  if l_num_rows > 0 then
    -- perform the XSL transformation
    l_json := l_xml.transform (xml(get_xml_to_json_stylesheet));
    l_returnvalue := l_json.getclobval();
  else
    l_returnvalue := g_json_null_object;
  end if;

  l_returnvalue := dbms_xmlgen.convert (l_returnvalue, dbms_xmlgen.entity_decode);

  if(l_num_rows = 0) then
    return json_list();
  else
    if(l_num_rows = 1) then
      declare ret json_list := json_list();
      begin
        ret.append(
          json(
            json(l_returnvalue).get('ROWSET')
          ).get('ROW')
        );
        return ret;
      end;
    else
      return json_list(json(l_returnvalue).get('ROWSET'));
    end if;
  end if;

exception
  when scanner_exception then
    RAISE NOTICE 'Scanner problem with the following input: ';
    RAISE NOTICE '%', l_returnvalue;
    raise;
  when parser_exception then
    RAISE NOTICE 'Parser problem with the following input: ';
    RAISE NOTICE '%', l_returnvalue;
    raise;
  when others then raise;
END;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION json_util_pkg.sql_to_json (p_sql in text,
                      p_max_rows in bigint DEFAULT null,
                      p_skip_rows in bigint DEFAULT null)  RETURNS json_list AS $body$
DECLARE

  v_cur REFCURSOR;

BEGIN
  open v_cur for p_sql;
  return ref_cursor_to_json(v_cur, p_max_rows, p_skip_rows);

END;

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'JSON_UTIL_PKG' declaration

-- Oracle package 'JSON_XML' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS json_xml CASCADE;
CREATE SCHEMA json_xml;


CREATE OR REPLACE FUNCTION json_xml.escapestr (str text)  RETURNS varchar AS $body$
DECLARE

    buf varchar(32767) := '';
    ch varchar(4);
  
BEGIN
    for i in 1 .. length(str) loop
      ch := substring(str from i for 1);
      case ch
      when '&' then buf := buf || '&amp;';
      when '<' then buf := buf || '&lt;';
      when '>' then buf := buf || '&gt;';
      when '"' then buf := buf || '&quot;';
      else buf := buf || ch;
      end case;
    end loop;
    return buf;
  END;

$body$
LANGUAGE PLPGSQL;


/* Clob methods from printer */


CREATE OR REPLACE FUNCTION json_xml.add_to_clob (buf_lob in out nocopy text, buf_str in out nocopy text, str text)  RETURNS RECORD AS $body$
BEGIN
    if(length(str) > 32767 - length(buf_str)) then
      dbms_lob.append(buf_lob, buf_str);
      buf_str := str;
    else
      buf_str := buf_str || str;
    end if;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION json_xml.flush_clob (buf_lob in out nocopy text, buf_str in out nocopy text)  RETURNS RECORD AS $body$
BEGIN
    dbms_lob.append(buf_lob, buf_str);
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION json_xml.tostring (obj json_value, tagname in text, xmlstr in out nocopy text, xmlbuf in out nocopy text)  RETURNS RECORD AS $body$
DECLARE

    v_obj json;
    v_list json_list;

    v_keys json_list;
    v_value json_value;
    key_str varchar(4000);
  
BEGIN
    if (obj.is_object()) then
      add_to_clob(xmlstr, xmlbuf, '<' || tagname || '>');
      v_obj := json(obj);

      v_keys := v_obj.get_keys();
      for i in 1 .. v_keys.count loop
        v_value := v_obj.get(i);
        key_str := v_keys.get(i).str;

        if(key_str = 'content') then
          if(v_value.is_array()) then
            declare
              v_l json_list := json_list(v_value);
            begin
              for j in 1 .. v_l.count loop
                if(j > 1) then add_to_clob(xmlstr, xmlbuf, chr(13)||chr(10)); end if;
                add_to_clob(xmlstr, xmlbuf, escapeStr(v_l.get(j).to_char()));
              end loop;
            end;
          else
            add_to_clob(xmlstr, xmlbuf, escapeStr(v_value.to_char()));
          end if;
        elsif(v_value.is_array()) then
          declare
            v_l json_list := json_list(v_value);
          begin
            for j in 1 .. v_l.count loop
              v_value := v_l.get(j);
              if(v_value.is_array()) then
                add_to_clob(xmlstr, xmlbuf, '<' || key_str || '>');
                add_to_clob(xmlstr, xmlbuf, escapeStr(v_value.to_char()));
                add_to_clob(xmlstr, xmlbuf, '</' || key_str || '>');
              else
                toString(v_value, key_str, xmlstr, xmlbuf);
              end if;
            end loop;
          end;
        elsif(v_value.is_null() or (v_value.is_string and v_value.get_string = '')) then
          add_to_clob(xmlstr, xmlbuf, '<' || key_str || '/>');
        else
          toString(v_value, key_str, xmlstr, xmlbuf);
        end if;
      end loop;

      add_to_clob(xmlstr, xmlbuf, '</' || tagname || '>');
    elsif (obj.is_array()) then
      v_list := json_list(obj);
      for i in 1 .. v_list.count loop
        v_value := v_list.get(i);
        toString(v_value, coalesce(tagname, 'array'), xmlstr, xmlbuf);
      end loop;
    else
      add_to_clob(xmlstr, xmlbuf, '<' || tagname || '>'||escapeStr(obj.to_char())||'</' || tagname || '>');
    end if;
  END;

$body$
LANGUAGE PLPGSQL;




CREATE OR REPLACE FUNCTION json_xml.json_to_xml (obj json, tagname text default 'root')  RETURNS xml AS $body$
DECLARE

    xmlstr text := empty_clob();
    xmlbuf varchar(32767) := '';
    returnValue xml;
  
BEGIN
    dbms_lob.createtemporary(xmlstr, true);

    toString(obj.to_json_value(), tagname, xmlstr, xmlbuf);

    flush_clob(xmlstr, xmlbuf);
    returnValue := xml('<?xml version="1.0"?>'||xmlstr);
    dbms_lob.freetemporary(xmlstr);
    return returnValue;
  end;

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'JSON_XML' declaration

-- Oracle package 'MATCH' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS match CASCADE;
CREATE SCHEMA match;

/******************************************************************************
   NAME: utility
   PURPOSE:

   REVISIONS:
   Ver Date Author Description
   --------- ---------- --------------- ------------------------------------
   1.0 5/11/2009 1. Created this package body.
   ******************************************************************************/


CREATE OR REPLACE FUNCTION match.reaction (searchtype   IN     text,
                       struct       IN     text,
                       ret             OUT SYS_REFCURSOR)
    RETURNS SYS_REFCURSOR AS $body$
DECLARE

      v_cursor   REFCURSOR;
      original   varchar(4000);
      reaction   text;
   
BEGIN
      IF searchtype = 'SSS'
      THEN
         -- SELECT LOG INTO reaction FROM tmp_log WHERE id = 228;
         --SELECT Bingo.AAM(struct, 'DISCARD') into reaction from dual;
         OPEN v_cursor FOR
            SELECT RXN_SCHEME_KEY,
                   (SELECT fullname
                      FROM cen_users
                     WHERE username = (SELECT username
                                         FROM cen_pages
                                        WHERE page_key = r.page_key))
                      AS username,
                   (SELECT notebook
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS notebook,
                   (SELECT experiment
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS page,
                   (SELECT creation_date
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS creation_date,
                   (SELECT subject
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS subject
              FROM cen_reaction_schemes r
             WHERE DBMS_LOB.getlength (r.native_rxn_sketch) > 0
                   AND bingo.Rsub (r.native_rxn_sketch, (struct)) = 1;
      --     AND bingo.Rsub (r.native_rxn_sketch, (select bingo.rsmiles(reaction) from dual)) = 1;
      ELSIF searchtype = 'Exact'
      THEN
         OPEN v_cursor FOR
            SELECT RXN_SCHEME_KEY,
                   (SELECT fullname
                      FROM cen_users
                     WHERE username = (SELECT username
                                         FROM cen_pages
                                        WHERE page_key = r.page_key))
                      AS username,
                   (SELECT notebook
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS notebook,
                   (SELECT experiment
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS page,
                   (SELECT creation_date
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS creation_date,
                   (SELECT subject
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS subject
              FROM cen_reaction_schemes r
             WHERE DBMS_LOB.getlength (r.native_rxn_sketch) > 0
                   AND bingo.Rexact (r.native_rxn_sketch, struct, 'NONE') = 1;
      END IF;

      ret := v_cursor;
   END;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION match.reactiontext ( queryText       IN     text,
                       ret             OUT SYS_REFCURSOR)
    RETURNS SYS_REFCURSOR AS $body$
DECLARE

      v_cursor   REFCURSOR;
      v_stmt_str varchar(4000);
   
BEGIN      
      v_stmt_str :=       'SELECT RXN_SCHEME_KEY,
                   (SELECT fullname
                      FROM cen_users
                     WHERE username = (SELECT username
                                         FROM cen_pages
                                        WHERE page_key = r.page_key))
                      AS username,
                   (SELECT notebook
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS notebook,
                   (SELECT experiment
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS page,
                   (SELECT creation_date
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS creation_date,
                   (SELECT subject
                      FROM cen_pages
                     WHERE page_key = r.page_key)
                      AS subject
              FROM PAGES_VW r
             WHERE ' ||  queryText;
             
              OPEN v_cursor FOR v_stmt_str ;
                    
                   ret := v_cursor;
   END;
   

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION match.get_reaction (reactId IN text, ret OUT text)
    RETURNS text AS $body$
DECLARE

      reaction   text;
   
BEGIN
      SELECT Bingo.rxnfile (r.native_rxn_sketch)
        INTO reaction
        FROM cen_reaction_schemes r
       WHERE DBMS_LOB.getlength (r.native_rxn_sketch) > 0
             AND RXN_SCHEME_KEY = reactId;

      ret := reactId || reaction;
   END;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION match.get_batch (vBatch     IN     text,
                        vType     IN     text,
                        compound      OUT text,
                        mw            OUT text,
                        mf            OUT text)
    RETURNS RECORD AS $body$
DECLARE

      strId     bigint;
      counter   bigint;
      vmw       varchar(100);
      vmf       varchar(100);
   
BEGIN
    if vType ='Batch' then
      SELECT cm.molweight, cm.molformula, cm.str_id
        INTO vmw, vmf, strId
        FROM mar_corp_str_assoc_t@LN_MAR_DDT10 csa,
             MAR_CORP_LOT_T@LN_MAR_DDT10 cl,
             mar_compound_mol_t@LN_MAR_DDT10 cm
       WHERE     csa.cmp_id = cl.cmp_id
             AND cm.str_id = csa.str_id
             AND cl.BATCH = vBatch;
    else
      SELECT distinct cm.molweight, cm.molformula, cm.str_id
        INTO vmw, vmf, strId
        FROM mar_corp_str_assoc_t@LN_MAR_DDT10 csa,
             MAR_CORP_LOT_T@LN_MAR_DDT10 cl,
             mar_compound_mol_t@LN_MAR_DDT10 cm
       WHERE     csa.cmp_id = cl.cmp_id
             AND cm.str_id = csa.str_id
             AND csa.corp_id = vBatch;
    end if;

      SELECT COUNT (str_id)
        INTO counter
        FROM tgv1
       WHERE str_id = strId;

      IF counter = 0
      THEN
         INSERT INTO tgv1
            SELECT COMPOUND, str_id
              FROM mar_compound_mol_t@LN_MAR_DDT10
             WHERE str_id = strId;

         COMMIT;
      ELSE
         counter := counter;
      END IF;

      SELECT COMPOUND
        INTO COMPOUND
        FROM tgv1
       WHERE str_id = strId;

      mw := vmw;
      mf := vmf;
   END;
   

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION match.get_bottle (vId     IN     text,
                        vType     IN     text,
                        compound      OUT text ,
                        mw            OUT text ,
                        mf            OUT text )
    RETURNS RECORD AS $body$
DECLARE

      strId     bigint;
      counter   bigint;
      vmw       varchar(100);
      vmf       varchar(100);
      vclob text;
   
BEGIN
   
   /* Formatted on 16/05/2014 16:13:01 (QP5 v5.136.908.31019) */
-- DELETE tgb1 WHERE str_id = vId;

--COMMIT;
      if vType = 'StrId' then
          SELECT cm.molweight, cm.molformula, cm.structure_id
            INTO vmw, vmf, strId
            FROM bottles.bot_structures_t@LN_BOTTLE_NMSDD cm
           WHERE     cm.structure_id= vId;
      elsif vType = 'CAS' then
          SELECT cm.molweight, cm.molformula, cm.structure_id
            INTO vmw, vmf, strId
            FROM bottles.bot_structures_t@LN_BOTTLE_NMSDD cm
           WHERE     cm.CAS_NUMBER= vId;
      else
         select s.molweight, s.molformula, s.structure_id 
            INTO vmw, vmf, strId
            from  bottles.BOT_STRUCTURES_T@LN_BOTTLE_NMSDD s, bottles.BOT_FORMULATIONS_T@LN_BOTTLE_NMSDD f, bottles.BOT_BOTTLES_T@LN_BOTTLE_NMSDD b
                where b.FORMULATION_ID= f.FORMULATION_ID
                and f.STRUCTURE_ID= s.STRUCTURE_ID
                and b.bottle_id = vId;      
      end if;
      

      SELECT COUNT (str_id)
        INTO counter
        FROM tgb1
       WHERE str_id = strId;

      IF counter = 0
      THEN
         INSERT INTO tgb1
            SELECT structure_molfile, structure_id
              FROM bottles.bot_structures_bingo_t@LN_BOTTLE_NMSDD
             WHERE structure_id = strId;

         COMMIT;
      ELSE
         counter := counter;
      END IF;

      SELECT COMPOUND
        INTO COMPOUND
        FROM tgb1
       WHERE str_id = strId;

      mw := vmw;
      mf := vmf;
     --    delete tgb1       WHERE str_id = vId;
     --           COMMIT;

   END;
   



$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION match.get_bottle_form (vId     IN     text,
                        vType     IN     text,
                        ret             OUT SYS_REFCURSOR )
    RETURNS SYS_REFCURSOR AS $body$
DECLARE

      v_cursor   REFCURSOR;
   
BEGIN

      if vType = 'StrId' then
            OPEN v_cursor FOR
            SELECT f.*, cas_number
                        FROM bottles.bot_structures_t@LN_BOTTLE_NMSDD cm, bottles.bot_formulations_v@LN_BOTTLE_NMSDD f
               WHERE     cm.structure_id=vId
                and cm.structure_id= f.structure_id;
      elsif vType = 'CAS' then
            OPEN v_cursor FOR
            SELECT f.*, cas_number
                        FROM bottles.bot_structures_t@LN_BOTTLE_NMSDD cm, bottles.bot_formulations_v@LN_BOTTLE_NMSDD f
               WHERE     cm.cas_number=vId
                and cm.structure_id= f.structure_id;
      else
            OPEN v_cursor FOR
            SELECT f.*, cas_number
            from  bottles.BOT_STRUCTURES_T@LN_BOTTLE_NMSDD s, bottles.BOT_FORMULATIONS_T@LN_BOTTLE_NMSDD f, bottles.BOT_BOTTLES_T@LN_BOTTLE_NMSDD b
                where b.FORMULATION_ID= f.FORMULATION_ID
                and f.STRUCTURE_ID= s.STRUCTURE_ID
                and b.bottle_id = vId;      
      end if;
              
    ret :=v_cursor;
    END;
    

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'MATCH' declaration

-- Oracle package 'REG' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS reg CASCADE;
CREATE SCHEMA reg;

/******************************************************************************
      NAME:       utility
      PURPOSE:

      REVISIONS:
      Ver        Date        Author           Description
      ---------  ----------  ---------------  ------------------------------------
      1.0        5/11/2009             1. Created this package body.
   ******************************************************************************/



CREATE OR REPLACE FUNCTION reg.delete_attachement (nb     IN     text,
                                exper   IN     text,
                                username   IN     text,
                                namedoc   IN     text,
                                ret           OUT text)
    RETURNS text AS $body$
DECLARE

   pk varchar(40) := '';
   i bigint;
   
BEGIN
    select A.ATTACHEMENT_KEY into pk from CEN_ATTACHEMENTS a, CEN_PAGES p where A.PAGE_KEY = P.PAGE_KEY and P.USERNAME =username and A.DOCUMENT_NAME =namedoc and NOTEBOOK = nb and EXPERIMENT = exper;
    delete CEN_ATTACHEMENTS where ATTACHEMENT_KEY = pk;
    commit;
         i := SQL%ROWCOUNT;
    ret := i;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;
   

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.delete_experiment (nb     IN     text,
                                exper   IN     text,
                                ret           OUT text)
    RETURNS text AS $body$
DECLARE

   pk varchar(40) := '';
   
BEGIN
    select page_key into pk from CEN_PAGES  where NOTEBOOK = nb and EXPERIMENT = exper;
    --delete  CEN_DEV_OWNER.CEN_NOTEBOOKS where notebook = '';
    delete CEN_DEV_OWNER.CEN_ATTACHEMENTS where page_key = pk;
    delete CEN_DEV_OWNER.CEN_BATCH_AMOUNTS where PAGE_KEY = pk;
    delete CEN_DEV_OWNER.CEN_BATCHES where PAGE_KEY = pk;
    delete CEN_DEV_OWNER.CEN_STRUCTURES where PAGE_KEY = pk;
    delete CEN_DEV_OWNER.CEN_REACTION_SCHEMES where PAGE_KEY = pk;
    delete CEN_DEV_OWNER.CEN_PAGES where page_key = pk;
    BINGO.FLUSHINSERTS ();
    commit;
       
    ret := '1';
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;
   
   

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.get_reaction (reactId IN text, ret OUT text)
    RETURNS text AS $body$
DECLARE

      reaction   text;
   
BEGIN
      SELECT Bingo.rxnfile (r.native_rxn_sketch)
        INTO reaction
        FROM cen_reaction_schemes r
       WHERE DBMS_LOB.getlength (r.native_rxn_sketch) > 0
             AND RXN_SCHEME_KEY = reactId;

      ret := reactId || reaction;
   END;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.insert_attachement (attach       IN     bytea,
                              nb     IN     text,
                              exper   IN     text,
                              docDesc   IN     text,
                              docName   IN     text,
                              docOrFiNa   IN     text,
                              ret             OUT text)
    RETURNS text AS $body$
DECLARE

      tmp      varchar(40);
      i        bigint;
      attKey   varchar(40);
      pageKey varchar(40);
   
BEGIN
        
        select PAGE_KEY into  pageKey from PAGES_VW where NOTEBOOK = nb and EXPERIMENT = exper;
        
      PERFORM DBMS_RANDOM.STRING ('A', TRUNC (DBMS_RANDOM.VALUE (40, 40)))
        INTO attKey
        ;

      INSERT INTO CEN_DEV_OWNER.CEN_ATTACHEMENTS (ATTACHEMENT_KEY,
                                                      PAGE_KEY,
                                                      DOCUMENT_DESCRIPTION,
                                                      DOCUMENT_NAME,
                                                      ORIGINAL_FILE_NAME,
                                                      LAST_MODIFIED)
          VALUES (attKey,
                  pageKey,
                  docDesc,
                  docName,
                  docOrFiNa,
                  LOCALTIMESTAMP);

      UPDATE CEN_ATTACHEMENTS
         SET BLOB_DATA = attach
       WHERE ATTACHEMENT_KEY = attKey;

      i := SQL%ROWCOUNT;
      
      ret := attKey;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;
   

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.insert_experiment (struct     IN     text,
                                Reagents   IN     text,
                                Products   IN     text,
                                workup     IN     text,
                                detail     IN     text,
                                ret           OUT text)
    RETURNS text AS $body$
DECLARE

      tmp        varchar(40);
      i          bigint;
      A          bigint := 0;
      retA    varchar(40);
      retPage    varchar(40);
      retBatch   varchar(40);
      retStruc   varchar(40);
      lenS       bigint;
      
       v_obj              json := json (detail);
       nb                 bigint := 0;

      v_notebook         varchar(8);
      v_owner_username   varchar(50);
      v_experiment       varchar(4);
            
   
BEGIN

      v_notebook := REPLACE (v_obj.PATH ('NOTEBOOK').TO_CHAR, '"');
      v_owner_username := REPLACE (v_obj.PATH ('OWNER_USERNAME').TO_CHAR, '"');
      v_experiment := REPLACE (v_obj.PATH ('EXPERIMENT').TO_CHAR, '"');
      
     
      
    SELECT COUNT (*)
        INTO nb
        FROM cen_pages
       WHERE notebook = v_notebook AND experiment = v_experiment;

 --raise_application_error ( -20101, 'nb ' ||nb );
 
    if  nb >0 then
        update_detail (detail, retA );
        update_schema (v_notebook , v_experiment,  'undefined'  ,  struct, retA);
        update_stoic (v_notebook , v_experiment, Reagents , Products ,  v_owner_username ,  retA);
        update_procedure (v_notebook , v_experiment, workup, retA);
--        raise_application_error ( -20101, 'nb ' || retA );
        ret := retA;
        commit;
        return;
    end if;
      


      insert_page (detail, workup, retPage);

      PERFORM LENGTH (retPage) INTO lenS ;

      IF lenS < 3
      THEN
         ret := retPage;
         ROLLBACK;
         RETURN;
      END IF;

      insert_reaction (struct,
                       retPage,
                       'INTENDED',
                       null,
                       retStruc);

      --raise_application_error (-20101, 'insert_reaction: ' || struct);

      PERFORM LENGTH (retStruc) INTO lenS ;

      IF lenS < 3
      THEN
         --raise_application_error (-20101, 'insert_reaction: ' || retStruc);
         ret := retStruc;
         ROLLBACK;
         RETURN;
      END IF;

      insert_batches (Reagents,
                      retPage,
                      REPLACE (v_obj.PATH ('OWNER_USERNAME').TO_CHAR, '"'),
                      retBatch);

      --raise_application_error (-20101, 'insert_products: ' || retPage);
      PERFORM LENGTH (retBatch) INTO lenS ;

      IF lenS < 3
      THEN
         ret := retBatch;
         ROLLBACK;
         RETURN;
      END IF;

      insert_batches (Products,
                      retPage,
                      REPLACE (v_obj.PATH ('OWNER_USERNAME').TO_CHAR, '"'),
                      retBatch);

      --raise_application_error (-20101, 'insert_reagents: ' || retPage);
      PERFORM LENGTH (retBatch) INTO lenS ;

      IF lenS < 3
      THEN
         ret := retBatch;
         ROLLBACK;
         RETURN;
      END IF;

      COMMIT;
      ret := '1';
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;



$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.insert_experiment_enum (struct       IN     text,
                                     structEnum   IN     text,
                                     detail       IN     text,
                                     ret             OUT text)
    RETURNS text AS $body$
DECLARE

      tmp        varchar(40);
      i          bigint;
      A          bigint := 0;
      retPage    varchar(40);
      retBatch   varchar(40);
      retStruc   varchar(40);
      lenS       bigint;
      v_obj      json;
      v_list     json_list;
      counter    bigint:=0;
      tmpLob text;
      c bigint :=0;
   
BEGIN
      v_obj := json (detail);
 --raise_application_error (-20101, 'struct: ' || structEnum);
      --            raise_application_error (
      --               -20101,
      --               'owner is missing ' || v_obj.PATH ('NOTEBOOK').TO_CHAR);


      insert_page (detail, '', retPage);

      --COMMIT;
      --raise_application_error (-20101, 'insert_page: ' || retPage);

      PERFORM LENGTH (retPage) INTO lenS ;

      IF lenS < 3
      THEN
         ret := retPage;
         ROLLBACK;
         RETURN;
      END IF;

      insert_reaction (struct,
                       retPage,
                       'INTENDED',
                       null,
                       retStruc);

      --raise_application_error (-20101, 'insert_reaction: ' || struct);

      PERFORM LENGTH (retStruc) INTO lenS ;

      IF lenS < 3
      THEN
         --raise_application_error (-20101, 'insert_reaction: ' || retStruc);
         ret := retStruc;
         ROLLBACK;
         RETURN;
      END IF;

--raise_application_error (-20101, '1: ' || structEnum);
LOOP
        counter := counter+1;
        
        select REGEXP_SUBSTR(s, '[^!]+', 1, counter) a
        into tmpLob
        from (select structEnum s );   
        
       --  raise_application_error (-20101, 'tmplob ' || tmpLob);
        if  length(tmpLob) >0 then
           
            insert_reaction (tmpLob,
                              retPage,
                              'ENUMERATED',
                              counter,
                              retStruc);
         end if;                 
        DBMS_OUTPUT.PUT_LINE(tmp) ;
        exit when  length(tmpLob) =0 ;
    END LOOP;
    
--raise_application_error (-20101, 'insert_reaction: 2' || retStruc);
      COMMIT;
      ret := '1';
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;




$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.insert_experiment_enum_batches (
                                Reagents   IN     text,
                                Products   IN     text,
                                detail     IN     text,
                                ret           OUT text)
    RETURNS text AS $body$
DECLARE

      tmp        varchar(40);
      i          bigint;
      A          bigint := 0;
      retPage    varchar(40);
      retBatch   varchar(40);
      retStruc   varchar(40);
      lenS       bigint;
      nb varchar(40);
      ex varchar(40);
      v_obj      json;
   
BEGIN
      v_obj := json (detail);
    nb:=REPLACE (v_obj.PATH ('NOTEBOOK').TO_CHAR, '"');
    ex:=REPLACE (v_obj.PATH ('EXPERIMENT').TO_CHAR, '"');

    
--                  raise_application_error (
--                     -20101,
--                     'nb exp ' || nb || ex  );--v_obj.PATH ('EXPERIMENT').TO_CHAR);
                     
   select page_key into retPage from cen_pages where notebook =nb  and experiment = ex;

--                  raise_application_error (
--                     -20101,
--                     'owner is missing ' || retPage || v_obj.PATH ('EXPERIMENT').TO_CHAR);

      insert_batches (Reagents,
                      retPage,
                      REPLACE (v_obj.PATH ('OWNER_USERNAME').TO_CHAR, '"'),
                      retBatch);

      --raise_application_error (-20101, 'insert_products: ' || retPage);
      PERFORM LENGTH (retBatch) INTO lenS ;

      IF lenS < 3
      THEN
         ret := retBatch;
         ROLLBACK;
         RETURN;
      END IF;

      insert_batches (Products,
                      retPage,
                      REPLACE (v_obj.PATH ('OWNER_USERNAME').TO_CHAR, '"'),
                      retBatch);

      --raise_application_error (-20101, 'insert_reagents: ' || retPage);
      PERFORM LENGTH (retBatch) INTO lenS ;

      IF lenS < 3
      THEN
         ret := retBatch;
         ROLLBACK;
         RETURN;
      END IF;

      COMMIT;
      ret := '1';
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;
   
   
 


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.insert_batches (batches    IN     text,
                             pageKey           text,
                             username          text,
                             ret           OUT text)
    RETURNS text AS $body$
DECLARE

      tmp         varchar(200);
      i           bigint;
      v_list      json_list;
      arrCount    bigint;
      batchKey    varchar(40);
      structKey   varchar(40);
      tmp0 text;
      tmp1 text;
      tmp2 text;
      v_nr bigint;
   
BEGIN
            v_nr := DBMS_LOB.GETLENGTH(batches);
            if  v_nr < 20 then
                ret := '1000';
                return;
            end if;
--            raise_application_error ( -20101, v_nr );
            v_nr :=0;
            v_nr := INSTR (batches,CHR(10), -1);
            
            if v_nr > 0 then
                SELECT REPLACE (batches, CHR(10),'') into tmp2 ;
                 v_list := json_list (tmp2);
            else 
                  v_list := json_list (batches);
            end if;
     
   --   raise_application_error ( -20101,  'arrivato 2 ' );
      arrCount := v_list.COUNT ();
  -- raise_application_error ( -20101,  'arrivato 1 ' );
      FOR i IN 1 .. arrCount
      LOOP
         SELECT DBMS_RANDOM.STRING ('A', TRUNC (DBMS_RANDOM.VALUE (40, 40)))
           INTO batchKey
           ;

         PERFORM DBMS_RANDOM.STRING ('A', TRUNC (DBMS_RANDOM.VALUE (40, 40)))
           INTO structKey
           ;

         INSERT INTO CEN_DEV_OWNER.CEN_STRUCTURES (STRUCT_KEY,
                                                   PAGE_KEY,
                                                   XML_METADATA,
                                                   CHEMICAL_NAME,
                                                   MOLECULAR_WEIGHT,
                                                   BOILING_PT_VALUE,
                                                   BOILING_PT_UNIT_CODE,
                                                   MELTING_PT_VALUE,
                                                   MELTING_PT_UNIT_CODE,
                                                   CREATED_BY_NOTEBOOK,
                                                   EXACT_MASS,
                                                   CAS_NUMBER,
                                                   USER_HAZARD_COMMENTS,
                                                   VERSION,
                                                   VIRTUAL_COMPOUND_ID,
                                                   LAST_MODIFIED)
             VALUES (structKey,
                     pageKey,
                     xml('<?xml version="1.0" encoding="UTF-8"?><Structure_Properties>   <Meta_Data>   </Meta_Data></Structure_Properties>'),
                     REPLACE (
                        v_list.PATH ('[' || i || '].CHEMICAL_NAME').TO_CHAR,
                        '"'),
                     TO_NUMBER (
                        REPLACE (
                           v_list.PATH (
                              '[' || i || '].BATCH_MW_VALUE').TO_CHAR,
                           '"'),
                        '99999.99999'),
                     0,
                     'C',
                     0,
                     'C',
                     'N',
                     0,
                     REPLACE (
                        v_list.PATH ('[' || i || '].CAS_NUMBER').TO_CHAR,
                        '"'),
                     REPLACE (
                        v_list.PATH ('[' || i || '].CHEMICAL_NAME').TO_CHAR,
                        '"'),
                     0,
                    TO_NUMBER (
                        REPLACE (
                           v_list.PATH (
                              '[' || i || '].REACTION_NUMBER').TO_CHAR,
                           '"'),
                        '99999'),                     
                     LOCALTIMESTAMP);

         INSERT INTO CEN_DEV_OWNER.CEN_BATCHES (BATCH_KEY,
                                                PAGE_KEY,
                                                BATCH_NUMBER,
                                                STRUCT_KEY,
                                                XML_METADATA,
                                                STEP_KEY,
                                                BATCH_TYPE,
                                                MOLECULAR_FORMULA,
                                                SALT_CODE,
                                                SALT_EQUIVS,
                                                LIST_KEY,
                                                BATCH_MW_VALUE,
                                                BATCH_MW_UNIT_CODE,
                                                BATCH_MW_IS_CALC,
                                                BATCH_MW_SIG_DIGITS,
                                                BATCH_MW_SIG_DIGITS_SET,
                                                BATCH_MW_USER_PREF_FIGS,
                                                IS_LIMITING,
                                                AUTO_CALC,
                                                SYNTHSZD_BY,
                                                INTD_ADDITION_ORDER,
                                                IS_CHLORACNEGEN,
                                                TESTED_FOR_CHLORACNEGEN,
                                                VERSION,
                                                LAST_MODIFIED)
             VALUES (batchKey,
                     pageKey,
                     REPLACE (
                        v_list.PATH ('[' || i || '].BATCH_NUMBER').TO_CHAR,
                        '"'),
                     structKey,
                     xml('<?xml version="1.0" encoding="UTF-8"?><Batch_Properties><Meta_Data><Owner></Owner><Comments></Comments><Container_Barcode></Container_Barcode><Stoich_Comments></Stoich_Comments><Stoic_Label>null</Stoic_Label><Reactants_For_Product></Reactants_For_Product><Analytical_Purity_List></Analytical_Purity_List><Precursors></Precursors><Analytical_Comment></Analytical_Comment><Screen_Panels></Screen_Panels><Enumeration_Sequence>0</Enumeration_Sequence></Meta_Data></Batch_Properties>'),
                     NULL,
                     REPLACE (
                        v_list.PATH ('[' || i || '].BATCH_TYPE').TO_CHAR,
                        '"'),
                     REPLACE (
                        v_list.PATH (
                           '[' || i || '].MOLECULAR_FORMULA').TO_CHAR,
                        '"'),
                     '00',
                     0,
                     NULL,
                     TO_NUMBER (
                        REPLACE (
                           v_list.PATH (
                              '[' || i || '].BATCH_MW_VALUE').TO_CHAR,
                           '"'),
                        '99999.99999'),
                     'SCAL',
                     'Y',
                     3,
                     'Y',
                     -1,
                     'N',
                     'Y',
                     username,
                     0,
                     'N',
                     'Y',
                     0,
                     LOCALTIMESTAMP);

         INSERT INTO CEN_DEV_OWNER.CEN_BATCH_AMOUNTS (BATCH_KEY,
                                                      PAGE_KEY,
                                                      WEIGHT_VALUE,
                                                      WEIGHT_UNIT_CODE,
                                                      THEO_WT_VALUE,
                                                      THEO_WT_UNIT_CODE,
                                                      THEO_YLD_PCNT_VALUE,
                                                      VOLUME_VALUE,
                                                      VOLUME_UNIT_CODE,
                                                      MOLARITY_VALUE,
                                                      MOLARITY_UNIT_CODE,
                                                      MOLE_VALUE,
                                                      MOLE_UNIT_CODE,
                                                      DENSITY_VALUE,
                                                      DENSITY_UNIT_CODE,
                                                      PURITY_VALUE,
                                                      PURITY_UNIT_CODE,
                                                      VERSION,
                                                      LAST_MODIFIED)
             VALUES (batchKey,
                     pageKey,
                     TO_NUMBER (
                        REPLACE (
                           v_list.PATH (
                              '[' || i || '].BATCH_MW_VALUE').TO_CHAR,
                           '"'),
                        '99999.99999'),
                     REPLACE (
                        v_list.PATH (
                           '[' || i || '].WEIGHT_UNIT_CODE').TO_CHAR,
                        '"'),
                     REPLACE (
                        v_list.PATH (
                           '[' || i || '].THEO_WT_VALUE').TO_CHAR,
                        '"'),
                     REPLACE (
                        v_list.PATH (
                           '[' || i || '].THEO_WT_UNIT_CODE').TO_CHAR,
                        '"'),
                     REPLACE (
                        v_list.PATH (
                           '[' || i || '].THEO_YLD_PCNT_VALUE').TO_CHAR,
                        '"'),
                     TO_NUMBER (
                        REPLACE (
                           v_list.PATH ('[' || i || '].VOLUME_VALUE').TO_CHAR,
                           '"'),
                        '99999.99999'),
                     REPLACE (
                        v_list.PATH (
                           '[' || i || '].VOLUME_UNIT_CODE').TO_CHAR,
                        '"'),
                     TO_NUMBER (
                        REPLACE (
                           v_list.PATH (
                              '[' || i || '].MOLARITY_VALUE').TO_CHAR,
                           '"'),
                        '99999.99999'),
                     REPLACE (
                        v_list.PATH (
                           '[' || i || '].MOLARITY_UNIT_CODE').TO_CHAR,
                        '"'),
                     TO_NUMBER (
                        REPLACE (
                           v_list.PATH ('[' || i || '].MOLE_VALUE').TO_CHAR,
                           '"'),
                        '99999.99999'),
                     REPLACE (
                        v_list.PATH ('[' || i || '].MOLE_UNIT_CODE').TO_CHAR,
                        '"'),
                     TO_NUMBER (
                        REPLACE (
                           v_list.PATH (
                              '[' || i || '].DENSITY_VALUE').TO_CHAR,
                           '"'),
                        '99999.99999'),
                     REPLACE (
                        v_list.PATH (
                           '[' || i || '].DENSITY_UNIT_CODE').TO_CHAR,
                        '"'),
                     TO_NUMBER (
                        REPLACE (
                           v_list.PATH ('[' || i || '].PURITY_VALUE').TO_CHAR,
                           '"'),
                        '99999.99999'),
                     REPLACE (
                        v_list.PATH (
                           '[' || i || '].PURITY_UNIT_CODE').TO_CHAR,
                        '"'),
                     0,
                     LOCALTIMESTAMP);
      --                     commit;
      --raise_application_error (-20101, 'insert_batches: ' || structKey ||  '  ' || pageKey);

      END LOOP;

      ret := '1000';
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.insert_reaction (struct       IN     text,
                              pageKey             text,
                              structType   IN     text,
                              nRea  in  bigint,
                              ret             OUT text)
    RETURNS text AS $body$
DECLARE

      tmp      varchar(40);
      i        bigint;
      rxnKey   varchar(40);
      v_nr bigint;
   
BEGIN
   
    v_nr := DBMS_LOB.GETLENGTH(struct);
--            raise_application_error ( -20101, 'rows ' || v_nr );
 --         raise_application_error (-20101, 'rxn ' || enumVal || '  pagekey  '  || exper);

            if  v_nr < 120 then -- empy structure circa 102
                ret := '1000';
                return;
            end if;

      PERFORM DBMS_RANDOM.STRING ('A', TRUNC (DBMS_RANDOM.VALUE (40, 40)))
        INTO rxnKey
        ;

      INSERT INTO CEN_DEV_OWNER.CEN_REACTION_SCHEMES (RXN_SCHEME_KEY,
                                                      PAGE_KEY,
                                                      REACTION_TYPE,
                                                      XML_METADATA,
                                                      SYNTH_ROUTE_REF,
                                                      VERSION,
                                                      LAST_MODIFIED)
          VALUES (rxnKey,
                  pageKey,
                  structType,
                  xml('<?xml version="1.0" encoding="UTF-8"?><Reaction_Properties><Meta_Data></Meta_Data></Reaction_Properties>'),
                  nRea,
                  0,
                  LOCALTIMESTAMP);

      UPDATE cen_reaction_schemes
         SET native_rxn_sketch = BINGO.COMPACTREACTION (struct, 1)
       WHERE RXN_SCHEME_KEY = rxnKey;

      i := SQL%ROWCOUNT;
      
      
      
      BINGO.FLUSHINSERTS ();

      ret := rxnKey;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.insert_detail (detail IN text, ret OUT text)
    RETURNS text AS $body$
DECLARE

      tmp                varchar(40);
      i                  bigint;
      v_obj              json := json (detail);
      nb                 bigint := 0;
      pk                 varchar(100);
      pageKey            varchar(40);
      v_notebook         varchar(8);
      v_owner_username   varchar(50);
      v_experiment       varchar(4);
   
BEGIN

      v_notebook := REPLACE (v_obj.PATH ('NOTEBOOK').TO_CHAR, '"');
      v_owner_username := REPLACE (v_obj.PATH ('OWNER_USERNAME').TO_CHAR, '"');
      v_experiment := REPLACE (v_obj.PATH ('EXPERIMENT').TO_CHAR, '"');

      SELECT COUNT (notebook)
        INTO nb
        FROM cen_notebooks
       WHERE notebook = v_notebook;

      --      raise_application_error (-20101,
      --                               'nb '|| nb || '  ' || v_notebook );

      IF nb = 0
      THEN
         INSERT INTO CEN_DEV_OWNER.CEN_NOTEBOOKS (SITE_CODE,
                                                  USERNAME,
                                                  NOTEBOOK,
                                                  STATUS,
                                                  XML_METADATA,
                                                  LAST_MODIFIED)
             VALUES ('SITE1',
                     v_owner_username,
                     v_notebook,
                     'OPEN',
                     xml('<?xml version="1.0" encoding="UTF-8"?><Notebook_Properties/>'),
                     LOCALTIMESTAMP);
      END IF;

      SELECT COUNT (notebook)
        INTO nb
        FROM cen_pages
       WHERE notebook = v_notebook AND experiment = v_experiment;

      IF nb = 1
      THEN
         ret := '-1';
         RETURN;
      END IF;

      PERFORM DBMS_RANDOM.STRING ('A', TRUNC (DBMS_RANDOM.VALUE (40, 40)))
        INTO pageKey
        ;

      INSERT INTO CEN_DEV_OWNER.CEN_PAGES (page_key,
                                           SITE_CODE,
                                           NOTEBOOK,
                                           EXPERIMENT,
                                           USERNAME,
                                           OWNER_USERNAME,
                                           LOOK_N_FEEL,
                                           PAGE_STATUS,
                                           CREATION_DATE,
                                           MODIFIED_DATE,
                                           XML_METADATA,
                                           FUNCTION,
                                           PAGE_VERSION,
                                           LATEST_VERSION,
                                           TA_CODE,
                                           PROJECT_CODE,
                                           LITERATURE_REF,
                                           SUBJECT,
                                           MIGRATED_TO_PCEN,
                                           BATCH_OWNER,
                                           BATCH_CREATOR,
                                           NBK_REF_VERSION,
                                           VERSION,
                                           YIELD,
                                           ISSUCCESSFUL)
          VALUES (pageKey,
                  'SITE1',
                  v_notebook,
                  v_experiment,
                  v_owner_username,
                  v_owner_username,
                  'MED-CHEM',
                  'OPEN',
                  LOCALTIMESTAMP,
                  LOCALTIMESTAMP,
                  xml('<?xml version="1.0" encoding="UTF-8"?><Page_Properties><Meta_Data><Archive_Date/><Signature_Url/><Table_Properties/><Ussi_Key>0</Ussi_Key><Auto_Calc_On>true</Auto_Calc_On><Cen_Version></Cen_Version><Completion_Date></Completion_Date><Continued_From_Rxn> </Continued_From_Rxn><Continued_To_Rxn> </Continued_To_Rxn><Project_Alias> </Project_Alias><DSP><Comments/><Description/><Procedure_Width>0</Procedure_Width><designUsers/><ScreenPanels/><Scale><Calculated>true</Calculated><Default_Value>0.0</Default_Value><Unit><Code></Code><Description></Description></Unit><Value>0</Value></Scale><PrototypeLeasdIDs/><DesignSite/><DesignCreationDate></DesignCreationDate><PID/><SummaryPID>null</SummaryPID><VrxnID/></DSP><ConceptionKeyWords/><ConceptorNames/></Meta_Data></Page_Properties>'),
                  null,
                  1,
                  'Y',
                  REPLACE (v_obj.PATH ('TH').TO_CHAR, '"'),
                  REPLACE (v_obj.PATH ('PROJECT_CODE').TO_CHAR, '"'),
                  REPLACE (v_obj.PATH ('LITERATURE_REF').TO_CHAR, '"'),
                  REPLACE (v_obj.PATH ('SUBJECT').TO_CHAR, '"'),
                  'N',
                  v_owner_username,
                  v_owner_username,
                  v_notebook || '-' || v_experiment || '-1',
                  0,
                  REPLACE (v_obj.PATH ('YIELD').TO_CHAR, '"'),
                  REPLACE (v_obj.PATH ('ISSUCCESSFUL').TO_CHAR, '"'));

      UPDATE CEN_PAGES
         SET XML_METADATA =
                UPDATEXML (
                   XML_METADATA,
                   '/Page_Properties/Meta_Data/Continued_From_Rxn/text()',
                   REPLACE (v_obj.PATH ('CONTINUED_FROM_RXN').TO_CHAR, '"'))
       WHERE page_key = pageKey;

      UPDATE CEN_PAGES
         SET XML_METADATA =
                UPDATEXML (
                   XML_METADATA,
                   '/Page_Properties/Meta_Data/Continued_To_Rxn/text()',
                   REPLACE (v_obj.PATH ('CONTINUED_TO_RXN').TO_CHAR, '"'))
       WHERE page_key = pageKey;

      UPDATE CEN_PAGES
         SET XML_METADATA =
                UPDATEXML (
                   XML_METADATA,
                   '/Page_Properties/Meta_Data/Project_Alias/text()',
                   REPLACE (v_obj.PATH ('PROJECT_ALIAS').TO_CHAR, '"'))
       WHERE page_key = pageKey;

      SELECT PAGE_KEY
        INTO pk
        FROM cen_pages
       WHERE notebook = v_notebook AND experiment = v_experiment;
        
       commit;
      ret := 1;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   --         raise_application_error (
   --            -20101,
   --            'owner is missing' || v_obj.PATH ('OWNER_USERNAME').TO_CHAR);
   END;


$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.insert_page (detail IN text, workup IN text, ret OUT text)
    RETURNS text AS $body$
DECLARE

      tmp                varchar(40);
      i                  bigint;
      v_obj              json := json (detail);
      nb                 bigint := 0;
      pk                 varchar(100);
      pageKey            varchar(40);
      v_notebook         varchar(8);
      v_owner_username   varchar(50);
      v_experiment       varchar(4);
   
BEGIN
      v_notebook := REPLACE (v_obj.PATH ('NOTEBOOK').TO_CHAR, '"');
      v_owner_username := REPLACE (v_obj.PATH ('OWNER_USERNAME').TO_CHAR, '"');
      v_experiment := REPLACE (v_obj.PATH ('EXPERIMENT').TO_CHAR, '"');

      SELECT COUNT (notebook)
        INTO nb
        FROM cen_notebooks
       WHERE notebook = v_notebook;

      --      raise_application_error (-20101,
      --                               'nb '|| nb || '  ' || v_notebook );

      IF nb = 0
      THEN
         INSERT INTO CEN_DEV_OWNER.CEN_NOTEBOOKS (SITE_CODE,
                                                  USERNAME,
                                                  NOTEBOOK,
                                                  STATUS,
                                                  XML_METADATA,
                                                  LAST_MODIFIED)
             VALUES ('SITE1',
                     v_owner_username,
                     v_notebook,
                     'OPEN',
                     xml('<?xml version="1.0" encoding="UTF-8"?><Notebook_Properties/>'),
                     LOCALTIMESTAMP);
      END IF;

      SELECT COUNT (notebook)
        INTO nb
        FROM cen_pages
       WHERE notebook = v_notebook AND experiment = v_experiment;

      IF nb = 1
      THEN
         ret := '-1';
         RETURN;
      END IF;

      PERFORM DBMS_RANDOM.STRING ('A', TRUNC (DBMS_RANDOM.VALUE (40, 40)))
        INTO pageKey
        ;

      INSERT INTO CEN_DEV_OWNER.CEN_PAGES (page_key,
                                           SITE_CODE,
                                           NOTEBOOK,
                                           EXPERIMENT,
                                           USERNAME,
                                           OWNER_USERNAME,
                                           LOOK_N_FEEL,
                                           PAGE_STATUS,
                                           CREATION_DATE,
                                           MODIFIED_DATE,
                                           XML_METADATA,
                                           FUNCTION,
                                           PAGE_VERSION,
                                           LATEST_VERSION,
                                           TA_CODE,
                                           PROJECT_CODE,
                                           LITERATURE_REF,
                                           SUBJECT,
                                           MIGRATED_TO_PCEN,
                                           BATCH_OWNER,
                                           BATCH_CREATOR,
                                           NBK_REF_VERSION,
                                           VERSION,
                                           YIELD,
                                           ISSUCCESSFUL)
          VALUES (pageKey,
                  'SITE1',
                  v_notebook,
                  v_experiment,
                  v_owner_username,
                  v_owner_username,
                  'MED-CHEM',
                  'OPEN',
                  LOCALTIMESTAMP,
                  LOCALTIMESTAMP,
                  xml('<?xml version="1.0" encoding="UTF-8"?><Page_Properties><Meta_Data><Archive_Date/><Signature_Url/><Table_Properties/><Ussi_Key>0</Ussi_Key><Auto_Calc_On>true</Auto_Calc_On><Cen_Version></Cen_Version><Completion_Date></Completion_Date><Continued_From_Rxn> </Continued_From_Rxn><Continued_To_Rxn> </Continued_To_Rxn><Project_Alias> </Project_Alias><DSP><Comments/><Description/><Procedure_Width>0</Procedure_Width><designUsers/><ScreenPanels/><Scale><Calculated>true</Calculated><Default_Value>0.0</Default_Value><Unit><Code></Code><Description></Description></Unit><Value>0</Value></Scale><PrototypeLeasdIDs/><DesignSite/><DesignCreationDate></DesignCreationDate><PID/><SummaryPID>null</SummaryPID><VrxnID/></DSP><ConceptionKeyWords/><ConceptorNames/></Meta_Data></Page_Properties>'),
                  workup,
                  1,
                  'Y',
                  REPLACE (v_obj.PATH ('TH').TO_CHAR, '"'),
                  REPLACE (v_obj.PATH ('PROJECT_CODE').TO_CHAR, '"'),
                  REPLACE (v_obj.PATH ('LITERATURE_REF').TO_CHAR, '"'),
                  REPLACE (v_obj.PATH ('SUBJECT').TO_CHAR, '"'),
                  'N',
                  v_owner_username,
                  v_owner_username,
                  v_notebook || '-' || v_experiment || '-1',
                  1,
                  REPLACE (v_obj.PATH ('YIELD').TO_CHAR, '"'),
                  REPLACE (v_obj.PATH ('ISSUCCESSFUL').TO_CHAR, '"'));

      UPDATE CEN_PAGES
         SET XML_METADATA =
                UPDATEXML (
                   XML_METADATA,
                   '/Page_Properties/Meta_Data/Continued_From_Rxn/text()',
                   REPLACE (v_obj.PATH ('CONTINUED_FROM_RXN').TO_CHAR, '"'))
       WHERE page_key = pageKey;

      UPDATE CEN_PAGES
         SET XML_METADATA =
                UPDATEXML (
                   XML_METADATA,
                   '/Page_Properties/Meta_Data/Continued_To_Rxn/text()',
                   REPLACE (v_obj.PATH ('CONTINUED_TO_RXN').TO_CHAR, '"'))
       WHERE page_key = pageKey;

      UPDATE CEN_PAGES
         SET XML_METADATA =
                UPDATEXML (
                   XML_METADATA,
                   '/Page_Properties/Meta_Data/Project_Alias/text()',
                   REPLACE (v_obj.PATH ('PROJECT_ALIAS').TO_CHAR, '"'))
       WHERE page_key = pageKey;

      SELECT PAGE_KEY
        INTO pk
        FROM cen_pages
       WHERE notebook = v_notebook AND experiment = v_experiment;

      ret := pk;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   --         raise_application_error (
   --            -20101,
   --            'owner is missing' || v_obj.PATH ('OWNER_USERNAME').TO_CHAR);
   END;
   

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.update_detail (detail IN text, ret OUT text)
    RETURNS text AS $body$
DECLARE

      tmp                varchar(40);
      i                  bigint;
      v_obj              json := json (detail);
      nb                 bigint := 0;
      pk                 varchar(100);
      pageKey            varchar(40);
      v_notebook         varchar(8);
      v_owner_username   varchar(50);
      v_experiment       varchar(4);
   
BEGIN
      v_notebook := REPLACE (v_obj.PATH ('NOTEBOOK').TO_CHAR, '"');
      v_owner_username := REPLACE (v_obj.PATH ('OWNER_USERNAME').TO_CHAR, '"');
      v_experiment := REPLACE (v_obj.PATH ('EXPERIMENT').TO_CHAR, '"');

      SELECT COUNT (notebook)
        INTO nb
        FROM cen_pages
       WHERE notebook = v_notebook AND experiment = v_experiment;

--      IF nb = 1
--      THEN
--         ret := '-1';
--         RETURN;
--      END IF;
--
--      SELECT DBMS_RANDOM.STRING ('A', TRUNC (DBMS_RANDOM.VALUE (40, 40)))
--        INTO pageKey
--        FROM DUAL;

      update CEN_DEV_OWNER.CEN_PAGES 
                  set TA_CODE = REPLACE (v_obj.PATH ('TH').TO_CHAR, '"'),
                  PROJECT_CODE = REPLACE (v_obj.PATH ('PROJECT_CODE').TO_CHAR, '"'),
                  LITERATURE_REF = REPLACE (v_obj.PATH ('LITERATURE_REF').TO_CHAR, '"'),
                  YIELD = REPLACE (v_obj.PATH ('YIELD').TO_CHAR, '"'),
                  ISSUCCESSFUL = REPLACE (v_obj.PATH ('ISSUCCESSFUL').TO_CHAR, '"'),
                  SUBJECT = REPLACE (v_obj.PATH ('SUBJECT').TO_CHAR, '"')
                   WHERE notebook = v_notebook AND experiment = v_experiment;

      UPDATE CEN_PAGES
         SET XML_METADATA =
                UPDATEXML (
                   XML_METADATA,
                   '/Page_Properties/Meta_Data/Continued_From_Rxn/text()',
                   REPLACE (v_obj.PATH ('CONTINUED_FROM_RXN').TO_CHAR, '"'))
       WHERE page_key = pageKey;

      UPDATE CEN_PAGES
         SET XML_METADATA =
                UPDATEXML (
                   XML_METADATA,
                   '/Page_Properties/Meta_Data/Continued_To_Rxn/text()',
                   REPLACE (v_obj.PATH ('CONTINUED_TO_RXN').TO_CHAR, '"'))
       WHERE page_key = pageKey;

      UPDATE CEN_PAGES
         SET XML_METADATA =
                UPDATEXML (
                   XML_METADATA,
                   '/Page_Properties/Meta_Data/Project_Alias/text()',
                   REPLACE (v_obj.PATH ('PROJECT_ALIAS').TO_CHAR, '"'))
       WHERE page_key = pageKey;

      ret := '1';
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   --         raise_application_error (
   --            -20101,
   --            'owner is missing' || v_obj.PATH ('OWNER_USERNAME').TO_CHAR);
   END;



$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.update_procedure (nb     IN     text,
                                exper   IN     text,
                                procedura IN text, ret OUT text)
    RETURNS text AS $body$
DECLARE

    v_nb bigint;
   
BEGIN
        
      update CEN_DEV_OWNER.CEN_PAGES 
                  set FUNCTION  = procedura
                   WHERE notebook = nb AND experiment = exper;
--                     raise_application_error ( -20101, 'nb ' || procedura );
      ret := '1';
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   --         raise_application_error (
   --            -20101,
   --            'owner is missing' || v_obj.PATH ('OWNER_USERNAME').TO_CHAR);
   END;
   

$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.update_schema (nb     IN     text,
                                exper   IN     text,
                                enumVal    IN     text,
                                struct   IN     text,
                                ret         OUT bigint)
    RETURNS bigint AS $body$
DECLARE

      tmp       varchar(40);
      rxnId     varchar(40);
      pageKey     varchar(40);
      ret1        varchar(40);
      i           bigint;
      lenS   bigint;
      isNull varchar(40);
   
BEGIN
   
   if enumVal ='' or enumVal ='undefined' then
        select RXN_SCHEME_KEY,  PAGE_KEY into rxnId, pageKey from PAGES_VW where NOTEBOOK = nb and EXPERIMENT = exper;
    else
--   raise_application_error ( -20101, 'nb ' ||enumVal );
        select RXN_SCHEME_KEY , PAGE_KEY into rxnId, pageKey from PAGES_VW where NOTEBOOK = nb and EXPERIMENT = exper and SYNTH_ROUTE_REF = enumVal;
    end if;
    

   SELECT coalesce(RXN_SCHEME_KEY, 'true') into isNull  from PAGES_VW where NOTEBOOK = nb and EXPERIMENT = exper;
   
    if isNull = 'true' then
--          raise_application_error (-20101, 'rxn ' || rxnId || '  pagekey  '  || exper);
         insert_reaction (struct , pageKey ,'INTENDED', null, ret1 );
        PERFORM LENGTH (ret1) INTO lenS ;
          IF lenS > 3
          THEN
             ret := 1;
         else
             ret := 0;         
          END IF;    
  else
      UPDATE cen_reaction_schemes
         SET native_rxn_sketch = BINGO.COMPACTREACTION (struct, 1)
       WHERE RXN_SCHEME_KEY = rxnId;
       
      i := SQL%ROWCOUNT;      
      BINGO.FLUSHINSERTS ();
      ret := i;
    end if;

   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;



$body$
LANGUAGE PLPGSQL;


CREATE OR REPLACE FUNCTION reg.update_stoic (nb     IN     text,
                                exper   IN     text,
                                Reagents   IN     text,
                                Products   IN     text,
                                username in text,
                                ret           OUT text)
    RETURNS text AS $body$
DECLARE

      pageKey    varchar(40);
      retBatch   varchar(40);
      lenS       bigint;
   
BEGIN
   
     SELECT page_key
        INTO pageKey
        FROM cen_pages
       WHERE notebook = nb AND experiment = exper;
       
      delete CEN_DEV_OWNER.CEN_BATCH_AMOUNTS where PAGE_KEY = pageKey;
      delete CEN_DEV_OWNER.CEN_BATCHES where PAGE_KEY = pageKey;


      insert_batches (Reagents,
                      pageKey,
                      username,
                      retBatch);

      --raise_application_error (-20101, 'insert_products: ' || retPage);
      PERFORM LENGTH (retBatch) INTO lenS ;

      IF lenS < 3
      THEN
         ret := retBatch;
         ROLLBACK;
         RETURN;
      END IF;

      insert_batches (Products,
                      pageKey,
                      username,
                      retBatch);

      --raise_application_error (-20101, 'insert_reagents: ' || retPage);
      PERFORM LENGTH (retBatch) INTO lenS ;

      IF lenS < 3
      THEN
         ret := retBatch;
         ROLLBACK;
         RETURN;
      END IF;

      COMMIT;
      ret := '1';
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END;
 

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'REG' declaration

-- Oracle package 'UTILITY' declaration, please edit to match PostgreSQL syntax.
-- PostgreSQL does not recognize PACKAGES, using SCHEMA instead.
DROP SCHEMA IF EXISTS utility CASCADE;
CREATE SCHEMA utility;

/******************************************************************************
      NAME:       utility
      PURPOSE:

      REVISIONS:
      Ver        Date        Author           Description
      ---------  ----------  ---------------  ------------------------------------
      1.0        5/11/2009             1. Created this package body.
   ******************************************************************************/



CREATE OR REPLACE FUNCTION utility.split (p_list text, p_del text DEFAULT ',')
       RETURNS SETOF split_tbl AS $body$
DECLARE

      l_idx     integer;
      l_list    varchar(32767) := p_list;
      l_value   varchar(32767);
   
BEGIN
      LOOP
         l_idx := INSTR (l_list, p_del);

         IF l_idx > 0
         THEN
            RETURN NEXT SUBSTR (l_list, 1, l_idx - 1);
            l_list := SUBSTR (l_list, l_idx + LENGTH (p_del));
         ELSE
            RETURN NEXT l_list;
            EXIT;
         END IF;
      END LOOP;

      RETURN;
   END;

$body$
LANGUAGE PLPGSQL;





CREATE OR REPLACE FUNCTION utility.join (p_cursor SYS_REFCURSOR, p_del text DEFAULT ',')
       RETURNS varchar AS $body$
DECLARE

      l_value    varchar(32767);
      l_result   varchar(32767);
   
BEGIN
      LOOP
         FETCH p_cursor INTO l_value;

         IF NOT FOUND THEN EXIT; END IF; -- apply on p_cursor

         IF (l_result IS NOT NULL AND l_result::text <> '')
         THEN
            l_result := l_result || p_del;
         END IF;

         l_result := l_result || l_value;
      END LOOP;

      RETURN l_result;
   END;

$body$
LANGUAGE PLPGSQL;





CREATE OR REPLACE FUNCTION utility.convert_string_to_table (p_table_string    text,
                                     p_sep             text DEFAULT ',')
       RETURNS SETOF STRING_TABLE_ITEM AS $body$
DECLARE

      v_buf        varchar(32767);
      v_old_buf    varchar(32767);
      v_item       varchar(32767);
      v_buf_size   integer;                               --  := 32767;
      v_amount     integer;
      v_offset     bigint;
      v_index_of   bigint;
   
BEGIN
      v_buf_size := 1024;
      v_amount := v_buf_size;
      v_offset := 1;

      WHILE v_amount >= v_buf_size
      LOOP
         DBMS_LOB.READ (lob_loc   => p_table_string,
                        amount    => v_amount,
                        offset    => v_offset,
                        buffer    => v_buf);
         v_offset := v_offset + v_amount;
         v_buf := v_old_buf || v_buf;

         LOOP
            v_index_of := INSTR (v_buf, p_sep, 1);

            IF v_index_of > 0
            THEN
               v_item := LTRIM (RTRIM (SUBSTR (v_buf, 1, v_index_of - 1)));

               IF LENGTH (v_item) > 0
               THEN
                  RETURN NEXT v_item;
               END IF;

               v_buf := SUBSTR (v_buf, v_index_of + LENGTH (p_sep));
            ELSE
               v_old_buf := v_buf;
               EXIT;
            END IF;
         END LOOP;
      END LOOP;

      v_item := LTRIM (RTRIM (v_buf));

      IF LENGTH (v_item) > 0
      THEN
         RETURN NEXT v_item;
      END IF;

      RETURN;
   END;

$body$
LANGUAGE PLPGSQL;
-- End of Oracle package 'UTILITY' declaration

